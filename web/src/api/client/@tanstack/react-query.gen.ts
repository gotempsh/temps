// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getPlatformInfo, recordEventMetrics, addSessionReplayEvents, initSessionReplay, recordSpeedMetrics, updateSpeedMetrics, getActiveVisitors, getEventsCount, getGeneralStats, getLiveVisitorsList, getPageHourlySessions, getPagePathDetail, getPagePaths, getSessionDetails, getSessionEvents, getSessionLogs, getVisitors, getVisitorByGuid, getVisitorById, getVisitorDetails, enrichVisitor, getVisitorInfo, getVisitorSessions, getVisitorStats, listApiKeys, createApiKey, getApiKeyPermissions, deleteApiKey, getApiKey, updateApiKey, activateApiKey, deactivateApiKey, getDeploymentJobLogs, ingestSentryEnvelope, ingestSentryEvent, emailStatus, login, requestMagicLink, verifyMagicLink, requestPasswordReset, resetPassword, verifyEmail, verifyMfaChallenge, runExternalServiceBackup, listS3Sources, createS3Source, deleteS3Source, getS3Source, updateS3Source, listSourceBackups, runBackupForSource, listBackupSchedules, createBackupSchedule, deleteBackupSchedule, getBackupSchedule, listBackupsForSchedule, disableBackupSchedule, enableBackupSchedule, getBackup, blobDelete, blobList, blobPut, blobCopy, blobDisable, blobEnable, blobStatus, blobUpdate, blobDownload, getActivityGraph, getScanByDeployment, listProviders, createProvider, deleteProvider, getProvider, updateProvider, listManagedDomains, addManagedDomain, testProviderConnection, listProviderZones, removeManagedDomain, verifyManagedDomain, lookupDnsARecords, listDomains, createDomain, getDomainByHost, cancelDomainOrder, getDomainOrder, createOrRecreateOrder, finalizeOrder, setupDnsChallenge, deleteDomain, getDomainById, getChallengeToken, getHttpChallengeDebug, provisionDomain, renewDomain, checkDomainStatus, listDomains2, createDomain2, getDomainByName, deleteDomain2, getDomain, getDomainDnsRecords, setupDns, verifyDomain, listProviders2, createProvider2, deleteProvider2, getProvider2, testProvider, listEmails, sendEmail, getEmailStats, validateEmail, getEmail, listServices, createService, listAvailableContainers, getServiceBySlug, importExternalService, listProjectServices, getProjectServiceEnvironmentVariables, getProvidersMetadata, getProviderMetadata, getServiceTypes, getServiceTypeParameters, deleteService, getService, updateService, getServicePreviewEnvironmentVariablesMasked, getServicePreviewEnvironmentVariableNames, listServiceProjects, linkServiceToProject, unlinkServiceFromProject, getServiceEnvironmentVariables, getServiceEnvironmentVariable, startService, stopService, upgradeService, listRootContainers, listContainersAtPath, listEntities, getEntityInfo, queryData, downloadObject, getContainerInfo, checkExplorerSupport, getFile, getIpGeolocation, listConnections, deleteConnection, activateConnection, deactivateConnection, listRepositoriesByConnection, syncRepositories, updateConnectionToken, validateConnection, listGitProviders, createGitProvider, createGithubPatProvider, createGitlabOauthProvider, createGitlabPatProvider, deleteProvider3, getGitProvider, activateProvider, handleGitProviderOauthCallback, getProviderConnections, deactivateProvider, checkProviderDeletionSafety, startGitProviderOauth, deleteProviderSafely, getPublicRepository, getPublicBranches, detectPublicPresets, discoverWorkloads, executeImport, createPlan, listSources, getImportStatus, getIncident, updateIncidentStatus, getIncidentUpdates, listIpAccessControl, createIpAccessControl, checkIpBlocked, deleteIpAccessControl, getIpAccessControl, updateIpAccessControl, kvDel, kvDisable, kvEnable, kvExpire, kvGet, kvIncr, kvKeys, kvSet, kvStatus, kvTtl, kvUpdate, listRoutes, createRoute, deleteRoute, getRoute, updateRoute, logout, deleteMonitor, getMonitor, getBucketedStatus, getCurrentMonitorStatus, getUptimeHistory, deletePreferences, getPreferences, updatePreferences, listNotificationProviders, createNotificationProvider, createEmailProvider, updateEmailProvider, createSlackProvider, updateSlackProvider, deleteProvider4, getNotificationProvider, updateProvider2, testProvider2, listOrders, hasPerformanceMetrics, getPerformanceMetrics, getMetricsOverTime, getGroupedPageMetrics, getAccessInfo, getPrivateIp, getPublicIp, listPresets, getProjects, createProject, getProjectBySlug, createProjectFromTemplate, getProjectStatistics, deleteProject, getProject, updateProject, getProjectDeployments, getLastDeployment, triggerProjectPipeline, getActiveVisitors2, getAggregatedBuckets, updateAutomaticDeploy, listCustomDomainsForProject, createCustomDomain, deleteCustomDomain, getCustomDomain, updateCustomDomain, linkCustomDomainToCertificate, updateProjectDeploymentConfig, getDeployment, cancelDeployment, getDeploymentJobs, tailDeploymentJobLogs, getDeploymentOperations, executeDeploymentOperation, getDeploymentOperationStatus, pauseDeployment, resumeDeployment, rollbackToDeployment, teardownDeployment, listDsns, createDsn, getOrCreateDsn, regenerateDsn, revokeDsn, getEnvironmentVariables, createEnvironmentVariable, getEnvironmentVariableValue, deleteEnvironmentVariable, updateEnvironmentVariable, getEnvironments, createEnvironment, deleteEnvironment, getEnvironment, getEnvironmentCrons, getCronById, getCronExecutions, getEnvironmentDomains, addEnvironmentDomain, deleteEnvironmentDomain, updateEnvironmentSettings, teardownEnvironment, getContainerLogs, listContainers, getContainerDetail, getContainerLogsById, getContainerMetrics, streamContainerMetrics, restartContainer, startContainer, stopContainer, getErrorDashboardStats, listErrorGroups, getErrorGroup, updateErrorGroup, listErrorEvents, getErrorEvent, getErrorStats, getErrorTimeSeries, getEventsCount2, getEventTypeBreakdown, getPropertyBreakdown, getPropertyTimeline, getEventsTimeline, getUniqueEvents, listFunnels, createFunnel, previewFunnelMetrics, deleteFunnel, updateFunnel, getFunnelMetrics, updateGitSettings, hasErrorGroups, hasAnalyticsEvents, getHourlyVisits, listExternalImages, pushExternalImage, getExternalImage, listIncidents, createIncident, getBucketedIncidents, listMonitors, createMonitor, updateProjectSettings, getStatusOverview, getUniqueCounts, listProjectScans, triggerScan, getLatestScansPerEnvironment, getLatestScan, listWebhooks, createWebhook, deleteWebhook, getWebhook, updateWebhook, listDeliveries, getDelivery, retryDelivery, getProxyLogs, getProxyLogByRequestId, getTimeBucketStats, getTodayStats, getProxyLogById, listSyncedRepositories, getRepositoryByName, getAllRepositoriesByName, getRepositoryPresetByName, getRepositoryBranches, getRepositoryTags, getRepositoryPresetLive, getBranchesByRepositoryId, checkCommitExists, getTagsByRepositoryId, getProjectSessionReplays, getSessionEvents2, getSettings, updateSettings, listTemplates, listTemplateTags, getTemplate, getCurrentUser, listUsers, createUser, updateSelf, disableMfa, setupMfa, verifyAndEnableMfa, deleteUser, updateUser, restoreUser, assignRole, removeRole, getVisitorSessions2, deleteSessionReplay, getSessionReplay, updateSessionDuration, getSessionReplayEvents, addEvents, deleteScan, getScan, getScanVulnerabilities, listEventTypes, triggerWeeklyDigest, listAuditLogs, getAuditLog } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetPlatformInfoData, RecordEventMetricsData, AddSessionReplayEventsData, AddSessionReplayEventsError, AddSessionReplayEventsResponse, InitSessionReplayData, InitSessionReplayError, InitSessionReplayResponse, RecordSpeedMetricsData, RecordSpeedMetricsError, UpdateSpeedMetricsData, UpdateSpeedMetricsError, GetActiveVisitorsData, GetEventsCountData, GetGeneralStatsData, GetLiveVisitorsListData, GetPageHourlySessionsData, GetPagePathDetailData, GetPagePathsData, GetSessionDetailsData, GetSessionEventsData, GetSessionEventsResponse, GetSessionLogsData, GetSessionLogsResponse, GetVisitorsData, GetVisitorsResponse, GetVisitorByGuidData, GetVisitorByIdData, GetVisitorDetailsData, EnrichVisitorData, EnrichVisitorResponse2 as EnrichVisitorResponse, GetVisitorInfoData, GetVisitorSessionsData, GetVisitorStatsData, ListApiKeysData, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyResponse2 as CreateApiKeyResponse, GetApiKeyPermissionsData, DeleteApiKeyData, DeleteApiKeyResponse, GetApiKeyData, UpdateApiKeyData, UpdateApiKeyResponse, ActivateApiKeyData, ActivateApiKeyResponse, DeactivateApiKeyData, DeactivateApiKeyResponse, GetDeploymentJobLogsData, IngestSentryEnvelopeData, IngestSentryEventData, IngestSentryEventResponse, EmailStatusData, LoginData, LoginResponse, RequestMagicLinkData, RequestMagicLinkResponse, VerifyMagicLinkData, RequestPasswordResetData, RequestPasswordResetResponse, ResetPasswordData, ResetPasswordResponse, VerifyEmailData, VerifyMfaChallengeData, VerifyMfaChallengeResponse, RunExternalServiceBackupData, RunExternalServiceBackupError, RunExternalServiceBackupResponse, ListS3SourcesData, CreateS3SourceData, CreateS3SourceError, CreateS3SourceResponse, DeleteS3SourceData, DeleteS3SourceError, DeleteS3SourceResponse, GetS3SourceData, UpdateS3SourceData, UpdateS3SourceError, UpdateS3SourceResponse, ListSourceBackupsData, RunBackupForSourceData, RunBackupForSourceError, RunBackupForSourceResponse, ListBackupSchedulesData, CreateBackupScheduleData, CreateBackupScheduleError, CreateBackupScheduleResponse, DeleteBackupScheduleData, DeleteBackupScheduleError, DeleteBackupScheduleResponse, GetBackupScheduleData, ListBackupsForScheduleData, DisableBackupScheduleData, DisableBackupScheduleResponse, EnableBackupScheduleData, EnableBackupScheduleResponse, GetBackupData, BlobDeleteData, BlobDeleteError, BlobDeleteResponse, BlobListData, BlobListError, BlobListResponse, BlobPutData, BlobPutError, BlobPutResponse, BlobCopyData, BlobCopyError, BlobCopyResponse, BlobDisableData, BlobDisableResponse, BlobEnableData, BlobEnableResponse, BlobStatusData, BlobUpdateData, BlobUpdateResponse, BlobDownloadData, GetActivityGraphData, GetScanByDeploymentData, ListProvidersData, CreateProviderData, CreateProviderResponse, DeleteProviderData, DeleteProviderResponse, GetProviderData, UpdateProviderData, UpdateProviderResponse, ListManagedDomainsData, AddManagedDomainData, AddManagedDomainResponse, TestProviderConnectionData, TestProviderConnectionResponse, ListProviderZonesData, RemoveManagedDomainData, RemoveManagedDomainResponse, VerifyManagedDomainData, VerifyManagedDomainResponse, LookupDnsARecordsData, ListDomainsData, CreateDomainData, CreateDomainResponse, GetDomainByHostData, CancelDomainOrderData, CancelDomainOrderResponse, GetDomainOrderData, CreateOrRecreateOrderData, CreateOrRecreateOrderResponse, FinalizeOrderData, FinalizeOrderResponse, SetupDnsChallengeData, SetupDnsChallengeResponse2 as SetupDnsChallengeResponse, DeleteDomainData, DeleteDomainResponse, GetDomainByIdData, GetChallengeTokenData, GetHttpChallengeDebugData, ProvisionDomainData, ProvisionDomainResponse, RenewDomainData, RenewDomainResponse, CheckDomainStatusData, ListDomains2Data, CreateDomain2Data, CreateDomain2Response, GetDomainByNameData, DeleteDomain2Data, DeleteDomain2Response, GetDomainData, GetDomainDnsRecordsData, SetupDnsData, SetupDnsResponse2 as SetupDnsResponse, VerifyDomainData, VerifyDomainResponse, ListProviders2Data, CreateProvider2Data, CreateProvider2Response, DeleteProvider2Data, DeleteProvider2Response, GetProvider2Data, TestProviderData, TestProviderResponse2 as TestProviderResponse, ListEmailsData, ListEmailsResponse, SendEmailData, SendEmailResponse, GetEmailStatsData, ValidateEmailData, ValidateEmailResponse2 as ValidateEmailResponse, GetEmailData, ListServicesData, CreateServiceData, CreateServiceResponse, ListAvailableContainersData, GetServiceBySlugData, ImportExternalServiceData, ImportExternalServiceResponse, ListProjectServicesData, GetProjectServiceEnvironmentVariablesData, GetProvidersMetadataData, GetProviderMetadataData, GetServiceTypesData, GetServiceTypeParametersData, DeleteServiceData, DeleteServiceResponse, GetServiceData, UpdateServiceData, UpdateServiceResponse, GetServicePreviewEnvironmentVariablesMaskedData, GetServicePreviewEnvironmentVariableNamesData, ListServiceProjectsData, LinkServiceToProjectData, LinkServiceToProjectResponse, UnlinkServiceFromProjectData, UnlinkServiceFromProjectResponse, GetServiceEnvironmentVariablesData, GetServiceEnvironmentVariableData, StartServiceData, StartServiceResponse, StopServiceData, StopServiceResponse, UpgradeServiceData, UpgradeServiceResponse, ListRootContainersData, ListContainersAtPathData, ListEntitiesData, GetEntityInfoData, QueryDataData, QueryDataResponse2 as QueryDataResponse, DownloadObjectData, GetContainerInfoData, CheckExplorerSupportData, GetFileData, GetIpGeolocationData, ListConnectionsData, ListConnectionsResponse, DeleteConnectionData, DeleteConnectionResponse, ActivateConnectionData, DeactivateConnectionData, ListRepositoriesByConnectionData, ListRepositoriesByConnectionResponse, SyncRepositoriesData, SyncRepositoriesResponse, UpdateConnectionTokenData, UpdateConnectionTokenResponse, ValidateConnectionData, ListGitProvidersData, CreateGitProviderData, CreateGitProviderResponse, CreateGithubPatProviderData, CreateGithubPatProviderResponse, CreateGitlabOauthProviderData, CreateGitlabOauthProviderResponse, CreateGitlabPatProviderData, CreateGitlabPatProviderResponse, DeleteProvider3Data, DeleteProvider3Response, GetGitProviderData, ActivateProviderData, HandleGitProviderOauthCallbackData, GetProviderConnectionsData, DeactivateProviderData, CheckProviderDeletionSafetyData, StartGitProviderOauthData, DeleteProviderSafelyData, DeleteProviderSafelyResponse, GetPublicRepositoryData, GetPublicBranchesData, DetectPublicPresetsData, DiscoverWorkloadsData, DiscoverWorkloadsResponse, ExecuteImportData, ExecuteImportResponse2 as ExecuteImportResponse, CreatePlanData, CreatePlanResponse2 as CreatePlanResponse, ListSourcesData, GetImportStatusData, GetIncidentData, UpdateIncidentStatusData, UpdateIncidentStatusResponse, GetIncidentUpdatesData, ListIpAccessControlData, CreateIpAccessControlData, CreateIpAccessControlResponse, CheckIpBlockedData, DeleteIpAccessControlData, DeleteIpAccessControlResponse, GetIpAccessControlData, UpdateIpAccessControlData, UpdateIpAccessControlResponse, KvDelData, KvDelResponse, KvDisableData, KvDisableResponse, KvEnableData, KvEnableResponse, KvExpireData, KvExpireResponse, KvGetData, KvGetResponse, KvIncrData, KvIncrResponse, KvKeysData, KvKeysResponse, KvSetData, KvSetResponse, KvStatusData, KvTtlData, KvTtlResponse, KvUpdateData, KvUpdateResponse, ListRoutesData, CreateRouteData, CreateRouteResponse, DeleteRouteData, DeleteRouteResponse, GetRouteData, UpdateRouteData, UpdateRouteResponse, LogoutData, DeleteMonitorData, DeleteMonitorResponse, GetMonitorData, GetBucketedStatusData, GetCurrentMonitorStatusData, GetUptimeHistoryData, DeletePreferencesData, DeletePreferencesResponse, GetPreferencesData, UpdatePreferencesData, UpdatePreferencesResponse, ListNotificationProvidersData, CreateNotificationProviderData, CreateNotificationProviderResponse, CreateEmailProviderData, CreateEmailProviderResponse, UpdateEmailProviderData, UpdateEmailProviderResponse, CreateSlackProviderData, CreateSlackProviderResponse, UpdateSlackProviderData, UpdateSlackProviderResponse, DeleteProvider4Data, DeleteProvider4Response, GetNotificationProviderData, UpdateProvider2Data, UpdateProvider2Response, TestProvider2Data, TestProvider2Response, ListOrdersData, HasPerformanceMetricsData, GetPerformanceMetricsData, GetMetricsOverTimeData, GetGroupedPageMetricsData, GetAccessInfoData, GetPrivateIpData, GetPublicIpData, ListPresetsData, GetProjectsData, GetProjectsResponse, CreateProjectData, CreateProjectResponse, GetProjectBySlugData, CreateProjectFromTemplateData, CreateProjectFromTemplateResponse2 as CreateProjectFromTemplateResponse, GetProjectStatisticsData, DeleteProjectData, DeleteProjectResponse, GetProjectData, UpdateProjectData, UpdateProjectResponse, GetProjectDeploymentsData, GetProjectDeploymentsResponse, GetLastDeploymentData, TriggerProjectPipelineData, TriggerProjectPipelineResponse, GetActiveVisitors2Data, GetAggregatedBucketsData, UpdateAutomaticDeployData, UpdateAutomaticDeployResponse, ListCustomDomainsForProjectData, CreateCustomDomainData, CreateCustomDomainResponse, DeleteCustomDomainData, DeleteCustomDomainResponse, GetCustomDomainData, UpdateCustomDomainData, UpdateCustomDomainResponse, LinkCustomDomainToCertificateData, LinkCustomDomainToCertificateResponse, UpdateProjectDeploymentConfigData, UpdateProjectDeploymentConfigResponse, GetDeploymentData, CancelDeploymentData, CancelDeploymentResponse, GetDeploymentJobsData, TailDeploymentJobLogsData, GetDeploymentOperationsData, ExecuteDeploymentOperationData, ExecuteDeploymentOperationResponse, GetDeploymentOperationStatusData, PauseDeploymentData, PauseDeploymentResponse, ResumeDeploymentData, ResumeDeploymentResponse, RollbackToDeploymentData, RollbackToDeploymentResponse, TeardownDeploymentData, TeardownDeploymentResponse, ListDsnsData, CreateDsnData, CreateDsnResponse, GetOrCreateDsnData, GetOrCreateDsnResponse, RegenerateDsnData, RegenerateDsnResponse, RevokeDsnData, RevokeDsnResponse, GetEnvironmentVariablesData, CreateEnvironmentVariableData, CreateEnvironmentVariableResponse, GetEnvironmentVariableValueData, DeleteEnvironmentVariableData, DeleteEnvironmentVariableResponse, UpdateEnvironmentVariableData, UpdateEnvironmentVariableResponse, GetEnvironmentsData, CreateEnvironmentData, CreateEnvironmentResponse, DeleteEnvironmentData, DeleteEnvironmentResponse, GetEnvironmentData, GetEnvironmentCronsData, GetCronByIdData, GetCronExecutionsData, GetCronExecutionsResponse, GetEnvironmentDomainsData, AddEnvironmentDomainData, AddEnvironmentDomainResponse, DeleteEnvironmentDomainData, DeleteEnvironmentDomainResponse, UpdateEnvironmentSettingsData, UpdateEnvironmentSettingsResponse, TeardownEnvironmentData, TeardownEnvironmentResponse, GetContainerLogsData, ListContainersData, GetContainerDetailData, GetContainerLogsByIdData, GetContainerMetricsData, StreamContainerMetricsData, RestartContainerData, RestartContainerResponse, StartContainerData, StartContainerResponse, StopContainerData, StopContainerResponse, GetErrorDashboardStatsData, ListErrorGroupsData, ListErrorGroupsResponse, GetErrorGroupData, UpdateErrorGroupData, ListErrorEventsData, ListErrorEventsResponse, GetErrorEventData, GetErrorStatsData, GetErrorTimeSeriesData, GetEventsCount2Data, GetEventTypeBreakdownData, GetPropertyBreakdownData, GetPropertyTimelineData, GetEventsTimelineData, GetUniqueEventsData, ListFunnelsData, CreateFunnelData, CreateFunnelResponse2 as CreateFunnelResponse, PreviewFunnelMetricsData, PreviewFunnelMetricsResponse, DeleteFunnelData, UpdateFunnelData, GetFunnelMetricsData, UpdateGitSettingsData, UpdateGitSettingsResponse, HasErrorGroupsData, HasAnalyticsEventsData, GetHourlyVisitsData, ListExternalImagesData, PushExternalImageData, PushExternalImageResponse, GetExternalImageData, ListIncidentsData, CreateIncidentData, CreateIncidentResponse, GetBucketedIncidentsData, ListMonitorsData, CreateMonitorData, CreateMonitorResponse, UpdateProjectSettingsData, UpdateProjectSettingsResponse, GetStatusOverviewData, GetUniqueCountsData, ListProjectScansData, ListProjectScansError, ListProjectScansResponse, TriggerScanData, TriggerScanError, TriggerScanResponse2 as TriggerScanResponse, GetLatestScansPerEnvironmentData, GetLatestScanData, ListWebhooksData, CreateWebhookData, CreateWebhookResponse, DeleteWebhookData, DeleteWebhookResponse, GetWebhookData, UpdateWebhookData, UpdateWebhookResponse, ListDeliveriesData, GetDeliveryData, RetryDeliveryData, RetryDeliveryResponse, GetProxyLogsData, GetProxyLogsResponse, GetProxyLogByRequestIdData, GetTimeBucketStatsData, GetTodayStatsData, GetProxyLogByIdData, ListSyncedRepositoriesData, ListSyncedRepositoriesResponse, GetRepositoryByNameData, GetAllRepositoriesByNameData, GetRepositoryPresetByNameData, GetRepositoryBranchesData, GetRepositoryTagsData, GetRepositoryPresetLiveData, GetBranchesByRepositoryIdData, CheckCommitExistsData, GetTagsByRepositoryIdData, GetProjectSessionReplaysData, GetProjectSessionReplaysError, GetProjectSessionReplaysResponse2 as GetProjectSessionReplaysResponse, GetSessionEvents2Data, GetSettingsData, UpdateSettingsData, UpdateSettingsResponse, ListTemplatesData, ListTemplateTagsData, GetTemplateData, GetCurrentUserData, ListUsersData, CreateUserData, CreateUserResponse, UpdateSelfData, UpdateSelfResponse, DisableMfaData, DisableMfaResponse, SetupMfaData, SetupMfaResponse, VerifyAndEnableMfaData, VerifyAndEnableMfaResponse, DeleteUserData, DeleteUserResponse, UpdateUserData, UpdateUserResponse, RestoreUserData, RestoreUserResponse, AssignRoleData, RemoveRoleData, RemoveRoleResponse, GetVisitorSessions2Data, GetVisitorSessions2Error, GetVisitorSessions2Response, DeleteSessionReplayData, DeleteSessionReplayError, GetSessionReplayData, UpdateSessionDurationData, UpdateSessionDurationError, UpdateSessionDurationResponse2 as UpdateSessionDurationResponse, GetSessionReplayEventsData, AddEventsData, AddEventsError, AddEventsResponse2 as AddEventsResponse, DeleteScanData, DeleteScanError, DeleteScanResponse, GetScanData, GetScanVulnerabilitiesData, GetScanVulnerabilitiesError, GetScanVulnerabilitiesResponse, ListEventTypesData, TriggerWeeklyDigestData, TriggerWeeklyDigestResponse, ListAuditLogsData, ListAuditLogsResponse, GetAuditLogData } from '../types.gen';
import { client } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getPlatformInfoQueryKey = (options?: Options<GetPlatformInfoData>) => createQueryKey('getPlatformInfo', options);

/**
 * Get platform information
 */
export const getPlatformInfoOptions = (options?: Options<GetPlatformInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPlatformInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPlatformInfoQueryKey(options)
    });
};

/**
 * Record analytics event
 */
export const recordEventMetricsMutation = (options?: Partial<Options<RecordEventMetricsData>>): UseMutationOptions<unknown, DefaultError, Options<RecordEventMetricsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RecordEventMetricsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await recordEventMetrics({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add events to existing session replay
 */
export const addSessionReplayEventsMutation = (options?: Partial<Options<AddSessionReplayEventsData>>): UseMutationOptions<AddSessionReplayEventsResponse, AddSessionReplayEventsError, Options<AddSessionReplayEventsData>> => {
    const mutationOptions: UseMutationOptions<AddSessionReplayEventsResponse, AddSessionReplayEventsError, Options<AddSessionReplayEventsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addSessionReplayEvents({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initialize session replay with metadata
 */
export const initSessionReplayMutation = (options?: Partial<Options<InitSessionReplayData>>): UseMutationOptions<InitSessionReplayResponse, InitSessionReplayError, Options<InitSessionReplayData>> => {
    const mutationOptions: UseMutationOptions<InitSessionReplayResponse, InitSessionReplayError, Options<InitSessionReplayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await initSessionReplay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Record performance metrics from client
 */
export const recordSpeedMetricsMutation = (options?: Partial<Options<RecordSpeedMetricsData>>): UseMutationOptions<unknown, RecordSpeedMetricsError, Options<RecordSpeedMetricsData>> => {
    const mutationOptions: UseMutationOptions<unknown, RecordSpeedMetricsError, Options<RecordSpeedMetricsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await recordSpeedMetrics({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update late performance metrics
 */
export const updateSpeedMetricsMutation = (options?: Partial<Options<UpdateSpeedMetricsData>>): UseMutationOptions<unknown, UpdateSpeedMetricsError, Options<UpdateSpeedMetricsData>> => {
    const mutationOptions: UseMutationOptions<unknown, UpdateSpeedMetricsError, Options<UpdateSpeedMetricsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSpeedMetrics({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActiveVisitorsQueryKey = (options: Options<GetActiveVisitorsData>) => createQueryKey('getActiveVisitors', options);

/**
 * Get detailed active visitors
 */
export const getActiveVisitorsOptions = (options: Options<GetActiveVisitorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActiveVisitors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActiveVisitorsQueryKey(options)
    });
};

export const getEventsCountQueryKey = (options: Options<GetEventsCountData>) => createQueryKey('getEventsCount', options);

export const getEventsCountOptions = (options: Options<GetEventsCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventsCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventsCountQueryKey(options)
    });
};

export const getGeneralStatsQueryKey = (options: Options<GetGeneralStatsData>) => createQueryKey('getGeneralStats', options);

/**
 * Get general statistics across all projects for a time frame
 */
export const getGeneralStatsOptions = (options: Options<GetGeneralStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGeneralStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGeneralStatsQueryKey(options)
    });
};

export const getLiveVisitorsListQueryKey = (options: Options<GetLiveVisitorsListData>) => createQueryKey('getLiveVisitorsList', options);

/**
 * Get list of currently live visitors from visitor table
 */
export const getLiveVisitorsListOptions = (options: Options<GetLiveVisitorsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLiveVisitorsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLiveVisitorsListQueryKey(options)
    });
};

export const getPageHourlySessionsQueryKey = (options: Options<GetPageHourlySessionsData>) => createQueryKey('getPageHourlySessions', options);

export const getPageHourlySessionsOptions = (options: Options<GetPageHourlySessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPageHourlySessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPageHourlySessionsQueryKey(options)
    });
};

export const getPagePathDetailQueryKey = (options: Options<GetPagePathDetailData>) => createQueryKey('getPagePathDetail', options);

/**
 * Get detailed analytics for a specific page path
 * Returns visitors, page views, activity over time, geographic distribution, and referrers
 */
export const getPagePathDetailOptions = (options: Options<GetPagePathDetailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPagePathDetail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPagePathDetailQueryKey(options)
    });
};

export const getPagePathsQueryKey = (options: Options<GetPagePathsData>) => createQueryKey('getPagePaths', options);

export const getPagePathsOptions = (options: Options<GetPagePathsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPagePaths({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPagePathsQueryKey(options)
    });
};

export const getSessionDetailsQueryKey = (options: Options<GetSessionDetailsData>) => createQueryKey('getSessionDetails', options);

/**
 * Get detailed information about a specific session including events and request logs
 */
export const getSessionDetailsOptions = (options: Options<GetSessionDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionDetailsQueryKey(options)
    });
};

export const getSessionEventsQueryKey = (options: Options<GetSessionEventsData>) => createQueryKey('getSessionEvents', options);

export const getSessionEventsOptions = (options: Options<GetSessionEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionEventsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getSessionEventsInfiniteQueryKey = (options: Options<GetSessionEventsData>): QueryKey<Options<GetSessionEventsData>> => createQueryKey('getSessionEvents', options, true);

export const getSessionEventsInfiniteOptions = (options: Options<GetSessionEventsData>) => {
    return infiniteQueryOptions<GetSessionEventsResponse, DefaultError, InfiniteData<GetSessionEventsResponse>, QueryKey<Options<GetSessionEventsData>>, number | Pick<QueryKey<Options<GetSessionEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetSessionEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getSessionEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionEventsInfiniteQueryKey(options)
    });
};

export const getSessionLogsQueryKey = (options: Options<GetSessionLogsData>) => createQueryKey('getSessionLogs', options);

export const getSessionLogsOptions = (options: Options<GetSessionLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionLogsQueryKey(options)
    });
};

export const getSessionLogsInfiniteQueryKey = (options: Options<GetSessionLogsData>): QueryKey<Options<GetSessionLogsData>> => createQueryKey('getSessionLogs', options, true);

export const getSessionLogsInfiniteOptions = (options: Options<GetSessionLogsData>) => {
    return infiniteQueryOptions<GetSessionLogsResponse, DefaultError, InfiniteData<GetSessionLogsResponse>, QueryKey<Options<GetSessionLogsData>>, number | Pick<QueryKey<Options<GetSessionLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetSessionLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getSessionLogs({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionLogsInfiniteQueryKey(options)
    });
};

export const getVisitorsQueryKey = (options: Options<GetVisitorsData>) => createQueryKey('getVisitors', options);

/**
 * Get list of visitors with summary information
 */
export const getVisitorsOptions = (options: Options<GetVisitorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorsQueryKey(options)
    });
};

export const getVisitorsInfiniteQueryKey = (options: Options<GetVisitorsData>): QueryKey<Options<GetVisitorsData>> => createQueryKey('getVisitors', options, true);

/**
 * Get list of visitors with summary information
 */
export const getVisitorsInfiniteOptions = (options: Options<GetVisitorsData>) => {
    return infiniteQueryOptions<GetVisitorsResponse, DefaultError, InfiniteData<GetVisitorsResponse>, QueryKey<Options<GetVisitorsData>>, number | Pick<QueryKey<Options<GetVisitorsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetVisitorsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getVisitors({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorsInfiniteQueryKey(options)
    });
};

export const getVisitorByGuidQueryKey = (options: Options<GetVisitorByGuidData>) => createQueryKey('getVisitorByGuid', options);

/**
 * Get visitor by GUID with geolocation data
 */
export const getVisitorByGuidOptions = (options: Options<GetVisitorByGuidData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorByGuid({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorByGuidQueryKey(options)
    });
};

export const getVisitorByIdQueryKey = (options: Options<GetVisitorByIdData>) => createQueryKey('getVisitorById', options);

/**
 * Get visitor by numeric ID with geolocation data
 */
export const getVisitorByIdOptions = (options: Options<GetVisitorByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorByIdQueryKey(options)
    });
};

export const getVisitorDetailsQueryKey = (options: Options<GetVisitorDetailsData>) => createQueryKey('getVisitorDetails', options);

/**
 * Get detailed information about a specific visitor by numeric ID
 */
export const getVisitorDetailsOptions = (options: Options<GetVisitorDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorDetailsQueryKey(options)
    });
};

export const enrichVisitorMutation = (options?: Partial<Options<EnrichVisitorData>>): UseMutationOptions<EnrichVisitorResponse, DefaultError, Options<EnrichVisitorData>> => {
    const mutationOptions: UseMutationOptions<EnrichVisitorResponse, DefaultError, Options<EnrichVisitorData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await enrichVisitor({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVisitorInfoQueryKey = (options: Options<GetVisitorInfoData>) => createQueryKey('getVisitorInfo', options);

/**
 * Get visitor record from database
 */
export const getVisitorInfoOptions = (options: Options<GetVisitorInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorInfoQueryKey(options)
    });
};

export const getVisitorSessionsQueryKey = (options: Options<GetVisitorSessionsData>) => createQueryKey('getVisitorSessions', options);

/**
 * Get all sessions for a specific visitor by numeric ID
 */
export const getVisitorSessionsOptions = (options: Options<GetVisitorSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorSessionsQueryKey(options)
    });
};

export const getVisitorStatsQueryKey = (options: Options<GetVisitorStatsData>) => createQueryKey('getVisitorStats', options);

/**
 * Get visitor statistics
 */
export const getVisitorStatsOptions = (options: Options<GetVisitorStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorStatsQueryKey(options)
    });
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

export const listApiKeysOptions = (options?: Options<ListApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysQueryKey(options)
    });
};

export const listApiKeysInfiniteQueryKey = (options?: Options<ListApiKeysData>): QueryKey<Options<ListApiKeysData>> => createQueryKey('listApiKeys', options, true);

export const listApiKeysInfiniteOptions = (options?: Options<ListApiKeysData>) => {
    return infiniteQueryOptions<ListApiKeysResponse, DefaultError, InfiniteData<ListApiKeysResponse>, QueryKey<Options<ListApiKeysData>>, number | Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listApiKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysInfiniteQueryKey(options)
    });
};

export const createApiKeyMutation = (options?: Partial<Options<CreateApiKeyData>>): UseMutationOptions<CreateApiKeyResponse, DefaultError, Options<CreateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<CreateApiKeyResponse, DefaultError, Options<CreateApiKeyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createApiKey({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyPermissionsQueryKey = (options?: Options<GetApiKeyPermissionsData>) => createQueryKey('getApiKeyPermissions', options);

export const getApiKeyPermissionsOptions = (options?: Options<GetApiKeyPermissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKeyPermissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyPermissionsQueryKey(options)
    });
};

export const deleteApiKeyMutation = (options?: Partial<Options<DeleteApiKeyData>>): UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiKey({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

export const getApiKeyOptions = (options: Options<GetApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyQueryKey(options)
    });
};

export const updateApiKeyMutation = (options?: Partial<Options<UpdateApiKeyData>>): UseMutationOptions<UpdateApiKeyResponse, DefaultError, Options<UpdateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<UpdateApiKeyResponse, DefaultError, Options<UpdateApiKeyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateApiKey({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const activateApiKeyMutation = (options?: Partial<Options<ActivateApiKeyData>>): UseMutationOptions<ActivateApiKeyResponse, DefaultError, Options<ActivateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<ActivateApiKeyResponse, DefaultError, Options<ActivateApiKeyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await activateApiKey({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deactivateApiKeyMutation = (options?: Partial<Options<DeactivateApiKeyData>>): UseMutationOptions<DeactivateApiKeyResponse, DefaultError, Options<DeactivateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<DeactivateApiKeyResponse, DefaultError, Options<DeactivateApiKeyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deactivateApiKey({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeploymentJobLogsQueryKey = (options: Options<GetDeploymentJobLogsData>) => createQueryKey('getDeploymentJobLogs', options);

/**
 * Get logs for a specific deployment job
 */
export const getDeploymentJobLogsOptions = (options: Options<GetDeploymentJobLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeploymentJobLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeploymentJobLogsQueryKey(options)
    });
};

/**
 * Ingest a Sentry envelope (binary payload)
 */
export const ingestSentryEnvelopeMutation = (options?: Partial<Options<IngestSentryEnvelopeData>>): UseMutationOptions<unknown, DefaultError, Options<IngestSentryEnvelopeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<IngestSentryEnvelopeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ingestSentryEnvelope({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Ingest a Sentry event (JSON payload)
 */
export const ingestSentryEventMutation = (options?: Partial<Options<IngestSentryEventData>>): UseMutationOptions<IngestSentryEventResponse, DefaultError, Options<IngestSentryEventData>> => {
    const mutationOptions: UseMutationOptions<IngestSentryEventResponse, DefaultError, Options<IngestSentryEventData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ingestSentryEvent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const emailStatusQueryKey = (options?: Options<EmailStatusData>) => createQueryKey('emailStatus', options);

export const emailStatusOptions = (options?: Options<EmailStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await emailStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: emailStatusQueryKey(options)
    });
};

export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const requestMagicLinkMutation = (options?: Partial<Options<RequestMagicLinkData>>): UseMutationOptions<RequestMagicLinkResponse, DefaultError, Options<RequestMagicLinkData>> => {
    const mutationOptions: UseMutationOptions<RequestMagicLinkResponse, DefaultError, Options<RequestMagicLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestMagicLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyMagicLinkQueryKey = (options: Options<VerifyMagicLinkData>) => createQueryKey('verifyMagicLink', options);

export const verifyMagicLinkOptions = (options: Options<VerifyMagicLinkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyMagicLink({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyMagicLinkQueryKey(options)
    });
};

export const requestPasswordResetMutation = (options?: Partial<Options<RequestPasswordResetData>>): UseMutationOptions<RequestPasswordResetResponse, DefaultError, Options<RequestPasswordResetData>> => {
    const mutationOptions: UseMutationOptions<RequestPasswordResetResponse, DefaultError, Options<RequestPasswordResetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetPasswordMutation = (options?: Partial<Options<ResetPasswordData>>): UseMutationOptions<ResetPasswordResponse, DefaultError, Options<ResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<ResetPasswordResponse, DefaultError, Options<ResetPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyEmailQueryKey = (options: Options<VerifyEmailData>) => createQueryKey('verifyEmail', options);

export const verifyEmailOptions = (options: Options<VerifyEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyEmailQueryKey(options)
    });
};

export const verifyMfaChallengeMutation = (options?: Partial<Options<VerifyMfaChallengeData>>): UseMutationOptions<VerifyMfaChallengeResponse, DefaultError, Options<VerifyMfaChallengeData>> => {
    const mutationOptions: UseMutationOptions<VerifyMfaChallengeResponse, DefaultError, Options<VerifyMfaChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await verifyMfaChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Run a backup for an external service manually
 */
export const runExternalServiceBackupMutation = (options?: Partial<Options<RunExternalServiceBackupData>>): UseMutationOptions<RunExternalServiceBackupResponse, RunExternalServiceBackupError, Options<RunExternalServiceBackupData>> => {
    const mutationOptions: UseMutationOptions<RunExternalServiceBackupResponse, RunExternalServiceBackupError, Options<RunExternalServiceBackupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await runExternalServiceBackup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listS3SourcesQueryKey = (options?: Options<ListS3SourcesData>) => createQueryKey('listS3Sources', options);

/**
 * List all S3 sources
 */
export const listS3SourcesOptions = (options?: Options<ListS3SourcesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listS3Sources({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listS3SourcesQueryKey(options)
    });
};

/**
 * Create a new S3 source
 */
export const createS3SourceMutation = (options?: Partial<Options<CreateS3SourceData>>): UseMutationOptions<CreateS3SourceResponse, CreateS3SourceError, Options<CreateS3SourceData>> => {
    const mutationOptions: UseMutationOptions<CreateS3SourceResponse, CreateS3SourceError, Options<CreateS3SourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createS3Source({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an S3 source
 */
export const deleteS3SourceMutation = (options?: Partial<Options<DeleteS3SourceData>>): UseMutationOptions<DeleteS3SourceResponse, DeleteS3SourceError, Options<DeleteS3SourceData>> => {
    const mutationOptions: UseMutationOptions<DeleteS3SourceResponse, DeleteS3SourceError, Options<DeleteS3SourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteS3Source({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getS3SourceQueryKey = (options: Options<GetS3SourceData>) => createQueryKey('getS3Source', options);

/**
 * Get an S3 source by ID
 */
export const getS3SourceOptions = (options: Options<GetS3SourceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getS3Source({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getS3SourceQueryKey(options)
    });
};

/**
 * Update an S3 source
 */
export const updateS3SourceMutation = (options?: Partial<Options<UpdateS3SourceData>>): UseMutationOptions<UpdateS3SourceResponse, UpdateS3SourceError, Options<UpdateS3SourceData>> => {
    const mutationOptions: UseMutationOptions<UpdateS3SourceResponse, UpdateS3SourceError, Options<UpdateS3SourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateS3Source({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSourceBackupsQueryKey = (options: Options<ListSourceBackupsData>) => createQueryKey('listSourceBackups', options);

/**
 * List all backups in an S3 source
 */
export const listSourceBackupsOptions = (options: Options<ListSourceBackupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSourceBackups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSourceBackupsQueryKey(options)
    });
};

/**
 * Run a backup immediately for an S3 source
 */
export const runBackupForSourceMutation = (options?: Partial<Options<RunBackupForSourceData>>): UseMutationOptions<RunBackupForSourceResponse, RunBackupForSourceError, Options<RunBackupForSourceData>> => {
    const mutationOptions: UseMutationOptions<RunBackupForSourceResponse, RunBackupForSourceError, Options<RunBackupForSourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await runBackupForSource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBackupSchedulesQueryKey = (options?: Options<ListBackupSchedulesData>) => createQueryKey('listBackupSchedules', options);

/**
 * List all backup schedules
 */
export const listBackupSchedulesOptions = (options?: Options<ListBackupSchedulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listBackupSchedules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listBackupSchedulesQueryKey(options)
    });
};

/**
 * Create a new backup schedule
 */
export const createBackupScheduleMutation = (options?: Partial<Options<CreateBackupScheduleData>>): UseMutationOptions<CreateBackupScheduleResponse, CreateBackupScheduleError, Options<CreateBackupScheduleData>> => {
    const mutationOptions: UseMutationOptions<CreateBackupScheduleResponse, CreateBackupScheduleError, Options<CreateBackupScheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBackupSchedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a backup schedule
 */
export const deleteBackupScheduleMutation = (options?: Partial<Options<DeleteBackupScheduleData>>): UseMutationOptions<DeleteBackupScheduleResponse, DeleteBackupScheduleError, Options<DeleteBackupScheduleData>> => {
    const mutationOptions: UseMutationOptions<DeleteBackupScheduleResponse, DeleteBackupScheduleError, Options<DeleteBackupScheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBackupSchedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupScheduleQueryKey = (options: Options<GetBackupScheduleData>) => createQueryKey('getBackupSchedule', options);

/**
 * Get a backup schedule by ID
 */
export const getBackupScheduleOptions = (options: Options<GetBackupScheduleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupSchedule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupScheduleQueryKey(options)
    });
};

export const listBackupsForScheduleQueryKey = (options: Options<ListBackupsForScheduleData>) => createQueryKey('listBackupsForSchedule', options);

/**
 * List backups for a schedule
 */
export const listBackupsForScheduleOptions = (options: Options<ListBackupsForScheduleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listBackupsForSchedule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listBackupsForScheduleQueryKey(options)
    });
};

/**
 * Disable a backup schedule
 */
export const disableBackupScheduleMutation = (options?: Partial<Options<DisableBackupScheduleData>>): UseMutationOptions<DisableBackupScheduleResponse, DefaultError, Options<DisableBackupScheduleData>> => {
    const mutationOptions: UseMutationOptions<DisableBackupScheduleResponse, DefaultError, Options<DisableBackupScheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await disableBackupSchedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable a backup schedule
 */
export const enableBackupScheduleMutation = (options?: Partial<Options<EnableBackupScheduleData>>): UseMutationOptions<EnableBackupScheduleResponse, DefaultError, Options<EnableBackupScheduleData>> => {
    const mutationOptions: UseMutationOptions<EnableBackupScheduleResponse, DefaultError, Options<EnableBackupScheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await enableBackupSchedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupQueryKey = (options: Options<GetBackupData>) => createQueryKey('getBackup', options);

/**
 * Get a backup by ID
 */
export const getBackupOptions = (options: Options<GetBackupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupQueryKey(options)
    });
};

/**
 * Delete blobs
 */
export const blobDeleteMutation = (options?: Partial<Options<BlobDeleteData>>): UseMutationOptions<BlobDeleteResponse, BlobDeleteError, Options<BlobDeleteData>> => {
    const mutationOptions: UseMutationOptions<BlobDeleteResponse, BlobDeleteError, Options<BlobDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const blobListQueryKey = (options?: Options<BlobListData>) => createQueryKey('blobList', options);

/**
 * List blobs
 */
export const blobListOptions = (options?: Options<BlobListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await blobList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: blobListQueryKey(options)
    });
};

export const blobListInfiniteQueryKey = (options?: Options<BlobListData>): QueryKey<Options<BlobListData>> => createQueryKey('blobList', options, true);

/**
 * List blobs
 */
export const blobListInfiniteOptions = (options?: Options<BlobListData>) => {
    return infiniteQueryOptions<BlobListResponse, BlobListError, InfiniteData<BlobListResponse>, QueryKey<Options<BlobListData>>, string | Pick<QueryKey<Options<BlobListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<BlobListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await blobList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: blobListInfiniteQueryKey(options)
    });
};

/**
 * Upload a blob
 */
export const blobPutMutation = (options?: Partial<Options<BlobPutData>>): UseMutationOptions<BlobPutResponse, BlobPutError, Options<BlobPutData>> => {
    const mutationOptions: UseMutationOptions<BlobPutResponse, BlobPutError, Options<BlobPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Copy a blob to a new location
 */
export const blobCopyMutation = (options?: Partial<Options<BlobCopyData>>): UseMutationOptions<BlobCopyResponse, BlobCopyError, Options<BlobCopyData>> => {
    const mutationOptions: UseMutationOptions<BlobCopyResponse, BlobCopyError, Options<BlobCopyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobCopy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disable Blob service
 */
export const blobDisableMutation = (options?: Partial<Options<BlobDisableData>>): UseMutationOptions<BlobDisableResponse, DefaultError, Options<BlobDisableData>> => {
    const mutationOptions: UseMutationOptions<BlobDisableResponse, DefaultError, Options<BlobDisableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobDisable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable Blob service
 */
export const blobEnableMutation = (options?: Partial<Options<BlobEnableData>>): UseMutationOptions<BlobEnableResponse, DefaultError, Options<BlobEnableData>> => {
    const mutationOptions: UseMutationOptions<BlobEnableResponse, DefaultError, Options<BlobEnableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobEnable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const blobStatusQueryKey = (options?: Options<BlobStatusData>) => createQueryKey('blobStatus', options);

/**
 * Get Blob service status
 */
export const blobStatusOptions = (options?: Options<BlobStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await blobStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: blobStatusQueryKey(options)
    });
};

/**
 * Update Blob service configuration
 */
export const blobUpdateMutation = (options?: Partial<Options<BlobUpdateData>>): UseMutationOptions<BlobUpdateResponse, DefaultError, Options<BlobUpdateData>> => {
    const mutationOptions: UseMutationOptions<BlobUpdateResponse, DefaultError, Options<BlobUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await blobUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const blobDownloadQueryKey = (options: Options<BlobDownloadData>) => createQueryKey('blobDownload', options);

/**
 * Download a blob
 */
export const blobDownloadOptions = (options: Options<BlobDownloadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await blobDownload({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: blobDownloadQueryKey(options)
    });
};

export const getActivityGraphQueryKey = (options?: Options<GetActivityGraphData>) => createQueryKey('getActivityGraph', options);

/**
 * Get deployment activity graph showing daily deployment counts
 * Similar to GitHub's contribution graph
 */
export const getActivityGraphOptions = (options?: Options<GetActivityGraphData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActivityGraph({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActivityGraphQueryKey(options)
    });
};

export const getScanByDeploymentQueryKey = (options: Options<GetScanByDeploymentData>) => createQueryKey('getScanByDeployment', options);

export const getScanByDeploymentOptions = (options: Options<GetScanByDeploymentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScanByDeployment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScanByDeploymentQueryKey(options)
    });
};

export const listProvidersQueryKey = (options?: Options<ListProvidersData>) => createQueryKey('listProviders', options);

/**
 * List all DNS providers
 */
export const listProvidersOptions = (options?: Options<ListProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProvidersQueryKey(options)
    });
};

/**
 * Create a new DNS provider
 * The provider's credentials will be tested before creation.
 * If the connection test fails, the provider will not be created.
 */
export const createProviderMutation = (options?: Partial<Options<CreateProviderData>>): UseMutationOptions<CreateProviderResponse, DefaultError, Options<CreateProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateProviderResponse, DefaultError, Options<CreateProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a DNS provider
 */
export const deleteProviderMutation = (options?: Partial<Options<DeleteProviderData>>): UseMutationOptions<DeleteProviderResponse, DefaultError, Options<DeleteProviderData>> => {
    const mutationOptions: UseMutationOptions<DeleteProviderResponse, DefaultError, Options<DeleteProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProviderQueryKey = (options: Options<GetProviderData>) => createQueryKey('getProvider', options);

/**
 * Get a DNS provider by ID
 */
export const getProviderOptions = (options: Options<GetProviderData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProvider({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProviderQueryKey(options)
    });
};

/**
 * Update a DNS provider
 */
export const updateProviderMutation = (options?: Partial<Options<UpdateProviderData>>): UseMutationOptions<UpdateProviderResponse, DefaultError, Options<UpdateProviderData>> => {
    const mutationOptions: UseMutationOptions<UpdateProviderResponse, DefaultError, Options<UpdateProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listManagedDomainsQueryKey = (options: Options<ListManagedDomainsData>) => createQueryKey('listManagedDomains', options);

/**
 * List managed domains for a provider
 */
export const listManagedDomainsOptions = (options: Options<ListManagedDomainsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listManagedDomains({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listManagedDomainsQueryKey(options)
    });
};

/**
 * Add a managed domain to a provider
 */
export const addManagedDomainMutation = (options?: Partial<Options<AddManagedDomainData>>): UseMutationOptions<AddManagedDomainResponse, DefaultError, Options<AddManagedDomainData>> => {
    const mutationOptions: UseMutationOptions<AddManagedDomainResponse, DefaultError, Options<AddManagedDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addManagedDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test provider connection
 */
export const testProviderConnectionMutation = (options?: Partial<Options<TestProviderConnectionData>>): UseMutationOptions<TestProviderConnectionResponse, DefaultError, Options<TestProviderConnectionData>> => {
    const mutationOptions: UseMutationOptions<TestProviderConnectionResponse, DefaultError, Options<TestProviderConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await testProviderConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listProviderZonesQueryKey = (options: Options<ListProviderZonesData>) => createQueryKey('listProviderZones', options);

/**
 * List zones available in a provider
 */
export const listProviderZonesOptions = (options: Options<ListProviderZonesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listProviderZones({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProviderZonesQueryKey(options)
    });
};

/**
 * Remove a managed domain
 */
export const removeManagedDomainMutation = (options?: Partial<Options<RemoveManagedDomainData>>): UseMutationOptions<RemoveManagedDomainResponse, DefaultError, Options<RemoveManagedDomainData>> => {
    const mutationOptions: UseMutationOptions<RemoveManagedDomainResponse, DefaultError, Options<RemoveManagedDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeManagedDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Verify a managed domain
 */
export const verifyManagedDomainMutation = (options?: Partial<Options<VerifyManagedDomainData>>): UseMutationOptions<VerifyManagedDomainResponse, DefaultError, Options<VerifyManagedDomainData>> => {
    const mutationOptions: UseMutationOptions<VerifyManagedDomainResponse, DefaultError, Options<VerifyManagedDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await verifyManagedDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lookupDnsARecordsQueryKey = (options: Options<LookupDnsARecordsData>) => createQueryKey('lookupDnsARecords', options);

/**
 * Lookup DNS A records for a domain
 */
export const lookupDnsARecordsOptions = (options: Options<LookupDnsARecordsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lookupDnsARecords({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lookupDnsARecordsQueryKey(options)
    });
};

export const listDomainsQueryKey = (options?: Options<ListDomainsData>) => createQueryKey('listDomains', options);

/**
 * List all domains
 */
export const listDomainsOptions = (options?: Options<ListDomainsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDomains({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDomainsQueryKey(options)
    });
};

/**
 * Create a new domain
 * Creates a new domain and automatically requests a Let's Encrypt challenge.
 * You can specify the challenge type (HTTP-01 or DNS-01) in the request.
 *
 * - **HTTP-01**: Validates domain ownership by placing a file on your web server at `/.well-known/acme-challenge/`
 * - **DNS-01**: Validates domain ownership by adding a TXT record to your DNS (required for wildcard domains)
 */
export const createDomainMutation = (options?: Partial<Options<CreateDomainData>>): UseMutationOptions<CreateDomainResponse, DefaultError, Options<CreateDomainData>> => {
    const mutationOptions: UseMutationOptions<CreateDomainResponse, DefaultError, Options<CreateDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainByHostQueryKey = (options: Options<GetDomainByHostData>) => createQueryKey('getDomainByHost', options);

/**
 * Get domain details by hostname
 */
export const getDomainByHostOptions = (options: Options<GetDomainByHostData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainByHost({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainByHostQueryKey(options)
    });
};

/**
 * Cancel ACME order for a domain
 * Cancels the current ACME order for a domain and clears all challenge data.
 * This allows you to start over with a new order if the previous one failed or got stuck.
 */
export const cancelDomainOrderMutation = (options?: Partial<Options<CancelDomainOrderData>>): UseMutationOptions<CancelDomainOrderResponse, DefaultError, Options<CancelDomainOrderData>> => {
    const mutationOptions: UseMutationOptions<CancelDomainOrderResponse, DefaultError, Options<CancelDomainOrderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelDomainOrder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainOrderQueryKey = (options: Options<GetDomainOrderData>) => createQueryKey('getDomainOrder', options);

/**
 * Get ACME order for a domain
 */
export const getDomainOrderOptions = (options: Options<GetDomainOrderData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainOrder({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainOrderQueryKey(options)
    });
};

/**
 * Create or recreate ACME order for a domain
 * Creates a new ACME order with Let's Encrypt for the specified domain.
 * If an order already exists, you should cancel it first using the cancel-order endpoint.
 * Returns the challenge details that need to be fulfilled (DNS record or HTTP token).
 */
export const createOrRecreateOrderMutation = (options?: Partial<Options<CreateOrRecreateOrderData>>): UseMutationOptions<CreateOrRecreateOrderResponse, DefaultError, Options<CreateOrRecreateOrderData>> => {
    const mutationOptions: UseMutationOptions<CreateOrRecreateOrderResponse, DefaultError, Options<CreateOrRecreateOrderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOrRecreateOrder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Finalize ACME order for a domain
 * Finalizes the ACME order by completing the challenge validation and requesting the certificate.
 * This should be called after the challenge has been set up (DNS record added or HTTP token served).
 */
export const finalizeOrderMutation = (options?: Partial<Options<FinalizeOrderData>>): UseMutationOptions<FinalizeOrderResponse, DefaultError, Options<FinalizeOrderData>> => {
    const mutationOptions: UseMutationOptions<FinalizeOrderResponse, DefaultError, Options<FinalizeOrderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await finalizeOrder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Setup DNS challenge records automatically using a DNS provider
 * This endpoint automatically creates the required DNS TXT records for ACME DNS-01 challenge
 * validation using a configured DNS provider. The domain must have an active DNS challenge
 * pending (created via POST /domains/{id}/order with dns-01 challenge type).
 *
 * This is similar to how email domain DNS records are auto-provisioned.
 */
export const setupDnsChallengeMutation = (options?: Partial<Options<SetupDnsChallengeData>>): UseMutationOptions<SetupDnsChallengeResponse, DefaultError, Options<SetupDnsChallengeData>> => {
    const mutationOptions: UseMutationOptions<SetupDnsChallengeResponse, DefaultError, Options<SetupDnsChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setupDnsChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a domain
 */
export const deleteDomainMutation = (options?: Partial<Options<DeleteDomainData>>): UseMutationOptions<DeleteDomainResponse, DefaultError, Options<DeleteDomainData>> => {
    const mutationOptions: UseMutationOptions<DeleteDomainResponse, DefaultError, Options<DeleteDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainByIdQueryKey = (options: Options<GetDomainByIdData>) => createQueryKey('getDomainById', options);

/**
 * Get domain by ID
 */
export const getDomainByIdOptions = (options: Options<GetDomainByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainByIdQueryKey(options)
    });
};

export const getChallengeTokenQueryKey = (options: Options<GetChallengeTokenData>) => createQueryKey('getChallengeToken', options);

/**
 * Get challenge token for a domain (returns plain text token)
 */
export const getChallengeTokenOptions = (options: Options<GetChallengeTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChallengeToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChallengeTokenQueryKey(options)
    });
};

export const getHttpChallengeDebugQueryKey = (options: Options<GetHttpChallengeDebugData>) => createQueryKey('getHttpChallengeDebug', options);

/**
 * Get HTTP challenge debug information
 * Returns detailed debug information for HTTP-01 challenge including:
 * - Whether a challenge exists for the domain
 * - The challenge token and URL that Let's Encrypt will access
 * - DNS resolution information showing where the domain currently points
 *
 * This is useful for debugging why HTTP-01 challenges fail.
 */
export const getHttpChallengeDebugOptions = (options: Options<GetHttpChallengeDebugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHttpChallengeDebug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHttpChallengeDebugQueryKey(options)
    });
};

/**
 * Provision a domain certificate
 */
export const provisionDomainMutation = (options?: Partial<Options<ProvisionDomainData>>): UseMutationOptions<ProvisionDomainResponse, DefaultError, Options<ProvisionDomainData>> => {
    const mutationOptions: UseMutationOptions<ProvisionDomainResponse, DefaultError, Options<ProvisionDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await provisionDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Renew domain certificate
 */
export const renewDomainMutation = (options?: Partial<Options<RenewDomainData>>): UseMutationOptions<RenewDomainResponse, DefaultError, Options<RenewDomainData>> => {
    const mutationOptions: UseMutationOptions<RenewDomainResponse, DefaultError, Options<RenewDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await renewDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const checkDomainStatusQueryKey = (options: Options<CheckDomainStatusData>) => createQueryKey('checkDomainStatus', options);

/**
 * Check domain status
 */
export const checkDomainStatusOptions = (options: Options<CheckDomainStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkDomainStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkDomainStatusQueryKey(options)
    });
};

export const listDomains2QueryKey = (options?: Options<ListDomains2Data>) => createQueryKey('listDomains2', options);

/**
 * List all email domains
 */
export const listDomains2Options = (options?: Options<ListDomains2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDomains2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDomains2QueryKey(options)
    });
};

/**
 * Create a new email domain
 */
export const createDomain2Mutation = (options?: Partial<Options<CreateDomain2Data>>): UseMutationOptions<CreateDomain2Response, DefaultError, Options<CreateDomain2Data>> => {
    const mutationOptions: UseMutationOptions<CreateDomain2Response, DefaultError, Options<CreateDomain2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDomain2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainByNameQueryKey = (options: Options<GetDomainByNameData>) => createQueryKey('getDomainByName', options);

/**
 * Get an email domain by domain name with DNS records
 */
export const getDomainByNameOptions = (options: Options<GetDomainByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainByNameQueryKey(options)
    });
};

/**
 * Delete an email domain
 */
export const deleteDomain2Mutation = (options?: Partial<Options<DeleteDomain2Data>>): UseMutationOptions<DeleteDomain2Response, DefaultError, Options<DeleteDomain2Data>> => {
    const mutationOptions: UseMutationOptions<DeleteDomain2Response, DefaultError, Options<DeleteDomain2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDomain2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainQueryKey = (options: Options<GetDomainData>) => createQueryKey('getDomain', options);

/**
 * Get an email domain by ID with DNS records
 */
export const getDomainOptions = (options: Options<GetDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainQueryKey(options)
    });
};

export const getDomainDnsRecordsQueryKey = (options: Options<GetDomainDnsRecordsData>) => createQueryKey('getDomainDnsRecords', options);

/**
 * Get DNS records for an email domain
 */
export const getDomainDnsRecordsOptions = (options: Options<GetDomainDnsRecordsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainDnsRecords({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainDnsRecordsQueryKey(options)
    });
};

/**
 * Setup DNS records for an email domain using a configured DNS provider
 */
export const setupDnsMutation = (options?: Partial<Options<SetupDnsData>>): UseMutationOptions<SetupDnsResponse, DefaultError, Options<SetupDnsData>> => {
    const mutationOptions: UseMutationOptions<SetupDnsResponse, DefaultError, Options<SetupDnsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setupDns({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Verify an email domain's DNS configuration
 */
export const verifyDomainMutation = (options?: Partial<Options<VerifyDomainData>>): UseMutationOptions<VerifyDomainResponse, DefaultError, Options<VerifyDomainData>> => {
    const mutationOptions: UseMutationOptions<VerifyDomainResponse, DefaultError, Options<VerifyDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await verifyDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listProviders2QueryKey = (options?: Options<ListProviders2Data>) => createQueryKey('listProviders2', options);

/**
 * List all email providers
 */
export const listProviders2Options = (options?: Options<ListProviders2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listProviders2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProviders2QueryKey(options)
    });
};

/**
 * Create a new email provider
 */
export const createProvider2Mutation = (options?: Partial<Options<CreateProvider2Data>>): UseMutationOptions<CreateProvider2Response, DefaultError, Options<CreateProvider2Data>> => {
    const mutationOptions: UseMutationOptions<CreateProvider2Response, DefaultError, Options<CreateProvider2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProvider2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an email provider
 */
export const deleteProvider2Mutation = (options?: Partial<Options<DeleteProvider2Data>>): UseMutationOptions<DeleteProvider2Response, DefaultError, Options<DeleteProvider2Data>> => {
    const mutationOptions: UseMutationOptions<DeleteProvider2Response, DefaultError, Options<DeleteProvider2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProvider2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProvider2QueryKey = (options: Options<GetProvider2Data>) => createQueryKey('getProvider2', options);

/**
 * Get an email provider by ID
 */
export const getProvider2Options = (options: Options<GetProvider2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProvider2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProvider2QueryKey(options)
    });
};

/**
 * Test an email provider by sending a test email to the logged-in user
 */
export const testProviderMutation = (options?: Partial<Options<TestProviderData>>): UseMutationOptions<TestProviderResponse, DefaultError, Options<TestProviderData>> => {
    const mutationOptions: UseMutationOptions<TestProviderResponse, DefaultError, Options<TestProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await testProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listEmailsQueryKey = (options?: Options<ListEmailsData>) => createQueryKey('listEmails', options);

/**
 * List emails with optional filtering
 */
export const listEmailsOptions = (options?: Options<ListEmailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEmails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEmailsQueryKey(options)
    });
};

export const listEmailsInfiniteQueryKey = (options?: Options<ListEmailsData>): QueryKey<Options<ListEmailsData>> => createQueryKey('listEmails', options, true);

/**
 * List emails with optional filtering
 */
export const listEmailsInfiniteOptions = (options?: Options<ListEmailsData>) => {
    return infiniteQueryOptions<ListEmailsResponse, DefaultError, InfiniteData<ListEmailsResponse>, QueryKey<Options<ListEmailsData>>, number | null | Pick<QueryKey<Options<ListEmailsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListEmailsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listEmails({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEmailsInfiniteQueryKey(options)
    });
};

/**
 * Send an email
 */
export const sendEmailMutation = (options?: Partial<Options<SendEmailData>>): UseMutationOptions<SendEmailResponse, DefaultError, Options<SendEmailData>> => {
    const mutationOptions: UseMutationOptions<SendEmailResponse, DefaultError, Options<SendEmailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await sendEmail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEmailStatsQueryKey = (options?: Options<GetEmailStatsData>) => createQueryKey('getEmailStats', options);

/**
 * Get email statistics
 */
export const getEmailStatsOptions = (options?: Options<GetEmailStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEmailStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEmailStatsQueryKey(options)
    });
};

/**
 * Validate an email address
 */
export const validateEmailMutation = (options?: Partial<Options<ValidateEmailData>>): UseMutationOptions<ValidateEmailResponse, DefaultError, Options<ValidateEmailData>> => {
    const mutationOptions: UseMutationOptions<ValidateEmailResponse, DefaultError, Options<ValidateEmailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await validateEmail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEmailQueryKey = (options: Options<GetEmailData>) => createQueryKey('getEmail', options);

/**
 * Get an email by ID
 */
export const getEmailOptions = (options: Options<GetEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEmailQueryKey(options)
    });
};

export const listServicesQueryKey = (options?: Options<ListServicesData>) => createQueryKey('listServices', options);

/**
 * Get all external services
 */
export const listServicesOptions = (options?: Options<ListServicesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listServices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listServicesQueryKey(options)
    });
};

/**
 * Create new external service
 */
export const createServiceMutation = (options?: Partial<Options<CreateServiceData>>): UseMutationOptions<CreateServiceResponse, DefaultError, Options<CreateServiceData>> => {
    const mutationOptions: UseMutationOptions<CreateServiceResponse, DefaultError, Options<CreateServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAvailableContainersQueryKey = (options?: Options<ListAvailableContainersData>) => createQueryKey('listAvailableContainers', options);

/**
 * List available Docker containers that can be imported as services
 */
export const listAvailableContainersOptions = (options?: Options<ListAvailableContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAvailableContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAvailableContainersQueryKey(options)
    });
};

export const getServiceBySlugQueryKey = (options: Options<GetServiceBySlugData>) => createQueryKey('getServiceBySlug', options);

/**
 * Get external service details by slug
 */
export const getServiceBySlugOptions = (options: Options<GetServiceBySlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServiceBySlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceBySlugQueryKey(options)
    });
};

/**
 * Import an existing Docker container as a managed external service
 */
export const importExternalServiceMutation = (options?: Partial<Options<ImportExternalServiceData>>): UseMutationOptions<ImportExternalServiceResponse, DefaultError, Options<ImportExternalServiceData>> => {
    const mutationOptions: UseMutationOptions<ImportExternalServiceResponse, DefaultError, Options<ImportExternalServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await importExternalService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listProjectServicesQueryKey = (options: Options<ListProjectServicesData>) => createQueryKey('listProjectServices', options);

/**
 * List services linked to a project
 */
export const listProjectServicesOptions = (options: Options<ListProjectServicesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listProjectServices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProjectServicesQueryKey(options)
    });
};

export const getProjectServiceEnvironmentVariablesQueryKey = (options: Options<GetProjectServiceEnvironmentVariablesData>) => createQueryKey('getProjectServiceEnvironmentVariables', options);

/**
 * Get all environment variables for all services linked to a project
 */
export const getProjectServiceEnvironmentVariablesOptions = (options: Options<GetProjectServiceEnvironmentVariablesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectServiceEnvironmentVariables({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectServiceEnvironmentVariablesQueryKey(options)
    });
};

export const getProvidersMetadataQueryKey = (options?: Options<GetProvidersMetadataData>) => createQueryKey('getProvidersMetadata', options);

/**
 * Get provider metadata (display names, icons, descriptions)
 */
export const getProvidersMetadataOptions = (options?: Options<GetProvidersMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProvidersMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProvidersMetadataQueryKey(options)
    });
};

export const getProviderMetadataQueryKey = (options: Options<GetProviderMetadataData>) => createQueryKey('getProviderMetadata', options);

/**
 * Get metadata for a specific provider
 */
export const getProviderMetadataOptions = (options: Options<GetProviderMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProviderMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProviderMetadataQueryKey(options)
    });
};

export const getServiceTypesQueryKey = (options?: Options<GetServiceTypesData>) => createQueryKey('getServiceTypes', options);

/**
 * Get available service types
 */
export const getServiceTypesOptions = (options?: Options<GetServiceTypesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServiceTypes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceTypesQueryKey(options)
    });
};

export const getServiceTypeParametersQueryKey = (options: Options<GetServiceTypeParametersData>) => createQueryKey('getServiceTypeParameters', options);

/**
 * Get parameter schema for a specific service type
 */
export const getServiceTypeParametersOptions = (options: Options<GetServiceTypeParametersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServiceTypeParameters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceTypeParametersQueryKey(options)
    });
};

/**
 * Delete external service
 */
export const deleteServiceMutation = (options?: Partial<Options<DeleteServiceData>>): UseMutationOptions<DeleteServiceResponse, DefaultError, Options<DeleteServiceData>> => {
    const mutationOptions: UseMutationOptions<DeleteServiceResponse, DefaultError, Options<DeleteServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServiceQueryKey = (options: Options<GetServiceData>) => createQueryKey('getService', options);

/**
 * Get external service details
 */
export const getServiceOptions = (options: Options<GetServiceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getService({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceQueryKey(options)
    });
};

/**
 * Update external service
 */
export const updateServiceMutation = (options?: Partial<Options<UpdateServiceData>>): UseMutationOptions<UpdateServiceResponse, DefaultError, Options<UpdateServiceData>> => {
    const mutationOptions: UseMutationOptions<UpdateServiceResponse, DefaultError, Options<UpdateServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServicePreviewEnvironmentVariablesMaskedQueryKey = (options: Options<GetServicePreviewEnvironmentVariablesMaskedData>) => createQueryKey('getServicePreviewEnvironmentVariablesMasked', options);

/**
 * Get environment variables preview with masked sensitive values
 */
export const getServicePreviewEnvironmentVariablesMaskedOptions = (options: Options<GetServicePreviewEnvironmentVariablesMaskedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServicePreviewEnvironmentVariablesMasked({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServicePreviewEnvironmentVariablesMaskedQueryKey(options)
    });
};

export const getServicePreviewEnvironmentVariableNamesQueryKey = (options: Options<GetServicePreviewEnvironmentVariableNamesData>) => createQueryKey('getServicePreviewEnvironmentVariableNames', options);

/**
 * Get environment variable names preview (safe - no sensitive values)
 */
export const getServicePreviewEnvironmentVariableNamesOptions = (options: Options<GetServicePreviewEnvironmentVariableNamesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServicePreviewEnvironmentVariableNames({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServicePreviewEnvironmentVariableNamesQueryKey(options)
    });
};

export const listServiceProjectsQueryKey = (options: Options<ListServiceProjectsData>) => createQueryKey('listServiceProjects', options);

/**
 * List projects linked to service
 */
export const listServiceProjectsOptions = (options: Options<ListServiceProjectsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listServiceProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listServiceProjectsQueryKey(options)
    });
};

/**
 * Link service to project
 */
export const linkServiceToProjectMutation = (options?: Partial<Options<LinkServiceToProjectData>>): UseMutationOptions<LinkServiceToProjectResponse, DefaultError, Options<LinkServiceToProjectData>> => {
    const mutationOptions: UseMutationOptions<LinkServiceToProjectResponse, DefaultError, Options<LinkServiceToProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkServiceToProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unlink service from project
 */
export const unlinkServiceFromProjectMutation = (options?: Partial<Options<UnlinkServiceFromProjectData>>): UseMutationOptions<UnlinkServiceFromProjectResponse, DefaultError, Options<UnlinkServiceFromProjectData>> => {
    const mutationOptions: UseMutationOptions<UnlinkServiceFromProjectResponse, DefaultError, Options<UnlinkServiceFromProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkServiceFromProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServiceEnvironmentVariablesQueryKey = (options: Options<GetServiceEnvironmentVariablesData>) => createQueryKey('getServiceEnvironmentVariables', options);

/**
 * Get all environment variables for a service-project pair
 */
export const getServiceEnvironmentVariablesOptions = (options: Options<GetServiceEnvironmentVariablesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServiceEnvironmentVariables({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceEnvironmentVariablesQueryKey(options)
    });
};

export const getServiceEnvironmentVariableQueryKey = (options: Options<GetServiceEnvironmentVariableData>) => createQueryKey('getServiceEnvironmentVariable', options);

/**
 * Get specific environment variable for a service-project pair
 */
export const getServiceEnvironmentVariableOptions = (options: Options<GetServiceEnvironmentVariableData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServiceEnvironmentVariable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServiceEnvironmentVariableQueryKey(options)
    });
};

/**
 * Start an external service
 */
export const startServiceMutation = (options?: Partial<Options<StartServiceData>>): UseMutationOptions<StartServiceResponse, DefaultError, Options<StartServiceData>> => {
    const mutationOptions: UseMutationOptions<StartServiceResponse, DefaultError, Options<StartServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await startService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Stop an external service
 */
export const stopServiceMutation = (options?: Partial<Options<StopServiceData>>): UseMutationOptions<StopServiceResponse, DefaultError, Options<StopServiceData>> => {
    const mutationOptions: UseMutationOptions<StopServiceResponse, DefaultError, Options<StopServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await stopService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upgrade external service to new Docker image with data migration
 * This endpoint uses service-specific upgrade procedures (e.g., pg_upgrade for PostgreSQL)
 */
export const upgradeServiceMutation = (options?: Partial<Options<UpgradeServiceData>>): UseMutationOptions<UpgradeServiceResponse, DefaultError, Options<UpgradeServiceData>> => {
    const mutationOptions: UseMutationOptions<UpgradeServiceResponse, DefaultError, Options<UpgradeServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await upgradeService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRootContainersQueryKey = (options: Options<ListRootContainersData>) => createQueryKey('listRootContainers', options);

/**
 * List containers at the root level (databases, keyspaces, etc.)
 */
export const listRootContainersOptions = (options: Options<ListRootContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRootContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRootContainersQueryKey(options)
    });
};

export const listContainersAtPathQueryKey = (options: Options<ListContainersAtPathData>) => createQueryKey('listContainersAtPath', options);

/**
 * List containers at a specific path
 * Path segments are separated by forward slashes
 * Example: /external-services/1/query/containers/mydb lists schemas in database "mydb"
 */
export const listContainersAtPathOptions = (options: Options<ListContainersAtPathData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listContainersAtPath({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listContainersAtPathQueryKey(options)
    });
};

export const listEntitiesQueryKey = (options: Options<ListEntitiesData>) => createQueryKey('listEntities', options);

/**
 * List entities (tables, collections, etc.) in a container
 * Example: /external-services/1/query/containers/mydb/public/entities lists tables in the public schema
 */
export const listEntitiesOptions = (options: Options<ListEntitiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEntities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEntitiesQueryKey(options)
    });
};

export const getEntityInfoQueryKey = (options: Options<GetEntityInfoData>) => createQueryKey('getEntityInfo', options);

/**
 * Get detailed information about an entity (table schema)
 */
export const getEntityInfoOptions = (options: Options<GetEntityInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEntityInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEntityInfoQueryKey(options)
    });
};

/**
 * Query data from an entity with optional filters, pagination, and sorting
 */
export const queryDataMutation = (options?: Partial<Options<QueryDataData>>): UseMutationOptions<QueryDataResponse, DefaultError, Options<QueryDataData>> => {
    const mutationOptions: UseMutationOptions<QueryDataResponse, DefaultError, Options<QueryDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await queryData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadObjectQueryKey = (options: Options<DownloadObjectData>) => createQueryKey('downloadObject', options);

/**
 * Download an object (S3 only) as a streaming response
 */
export const downloadObjectOptions = (options: Options<DownloadObjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadObject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadObjectQueryKey(options)
    });
};

export const getContainerInfoQueryKey = (options: Options<GetContainerInfoData>) => createQueryKey('getContainerInfo', options);

/**
 * Get information about a specific container
 */
export const getContainerInfoOptions = (options: Options<GetContainerInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerInfoQueryKey(options)
    });
};

export const checkExplorerSupportQueryKey = (options: Options<CheckExplorerSupportData>) => createQueryKey('checkExplorerSupport', options);

/**
 * Check if a service supports query explorer functionality
 */
export const checkExplorerSupportOptions = (options: Options<CheckExplorerSupportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkExplorerSupport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkExplorerSupportQueryKey(options)
    });
};

export const getFileQueryKey = (options: Options<GetFileData>) => createQueryKey('getFile', options);

export const getFileOptions = (options: Options<GetFileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFileQueryKey(options)
    });
};

export const getIpGeolocationQueryKey = (options: Options<GetIpGeolocationData>) => createQueryKey('getIpGeolocation', options);

/**
 * Get geolocation information for an IP address
 */
export const getIpGeolocationOptions = (options: Options<GetIpGeolocationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIpGeolocation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getIpGeolocationQueryKey(options)
    });
};

export const listConnectionsQueryKey = (options?: Options<ListConnectionsData>) => createQueryKey('listConnections', options);

/**
 * List user's git provider connections
 */
export const listConnectionsOptions = (options?: Options<ListConnectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listConnections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listConnectionsQueryKey(options)
    });
};

export const listConnectionsInfiniteQueryKey = (options?: Options<ListConnectionsData>): QueryKey<Options<ListConnectionsData>> => createQueryKey('listConnections', options, true);

/**
 * List user's git provider connections
 */
export const listConnectionsInfiniteOptions = (options?: Options<ListConnectionsData>) => {
    return infiniteQueryOptions<ListConnectionsResponse, DefaultError, InfiniteData<ListConnectionsResponse>, QueryKey<Options<ListConnectionsData>>, number | Pick<QueryKey<Options<ListConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listConnections({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listConnectionsInfiniteQueryKey(options)
    });
};

/**
 * Permanently delete a git provider connection
 */
export const deleteConnectionMutation = (options?: Partial<Options<DeleteConnectionData>>): UseMutationOptions<DeleteConnectionResponse, DefaultError, Options<DeleteConnectionData>> => {
    const mutationOptions: UseMutationOptions<DeleteConnectionResponse, DefaultError, Options<DeleteConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Activate a git provider connection
 */
export const activateConnectionMutation = (options?: Partial<Options<ActivateConnectionData>>): UseMutationOptions<unknown, DefaultError, Options<ActivateConnectionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ActivateConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await activateConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deactivate a git provider connection
 */
export const deactivateConnectionMutation = (options?: Partial<Options<DeactivateConnectionData>>): UseMutationOptions<unknown, DefaultError, Options<DeactivateConnectionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeactivateConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deactivateConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRepositoriesByConnectionQueryKey = (options: Options<ListRepositoriesByConnectionData>) => createQueryKey('listRepositoriesByConnection', options);

/**
 * List repositories for a specific connection
 * Fetches repositories from the connected git provider with support for pagination, search, and filtering.
 * This endpoint calls the provider's API directly to get the most up-to-date repository list.
 */
export const listRepositoriesByConnectionOptions = (options: Options<ListRepositoriesByConnectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRepositoriesByConnection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRepositoriesByConnectionQueryKey(options)
    });
};

export const listRepositoriesByConnectionInfiniteQueryKey = (options: Options<ListRepositoriesByConnectionData>): QueryKey<Options<ListRepositoriesByConnectionData>> => createQueryKey('listRepositoriesByConnection', options, true);

/**
 * List repositories for a specific connection
 * Fetches repositories from the connected git provider with support for pagination, search, and filtering.
 * This endpoint calls the provider's API directly to get the most up-to-date repository list.
 */
export const listRepositoriesByConnectionInfiniteOptions = (options: Options<ListRepositoriesByConnectionData>) => {
    return infiniteQueryOptions<ListRepositoriesByConnectionResponse, DefaultError, InfiniteData<ListRepositoriesByConnectionResponse>, QueryKey<Options<ListRepositoriesByConnectionData>>, number | Pick<QueryKey<Options<ListRepositoriesByConnectionData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListRepositoriesByConnectionData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listRepositoriesByConnection({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRepositoriesByConnectionInfiniteQueryKey(options)
    });
};

/**
 * Sync repositories from a connection
 * Synchronizes repository data from the git provider to the local database.
 * This updates the local cache of repositories for faster access.
 */
export const syncRepositoriesMutation = (options?: Partial<Options<SyncRepositoriesData>>): UseMutationOptions<SyncRepositoriesResponse, DefaultError, Options<SyncRepositoriesData>> => {
    const mutationOptions: UseMutationOptions<SyncRepositoriesResponse, DefaultError, Options<SyncRepositoriesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await syncRepositories({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update access token for a connection (when tokens expire or are rotated)
 */
export const updateConnectionTokenMutation = (options?: Partial<Options<UpdateConnectionTokenData>>): UseMutationOptions<UpdateConnectionTokenResponse, DefaultError, Options<UpdateConnectionTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateConnectionTokenResponse, DefaultError, Options<UpdateConnectionTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateConnectionToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const validateConnectionQueryKey = (options: Options<ValidateConnectionData>) => createQueryKey('validateConnection', options);

/**
 * Validate a connection by testing the access token
 */
export const validateConnectionOptions = (options: Options<ValidateConnectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await validateConnection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: validateConnectionQueryKey(options)
    });
};

export const listGitProvidersQueryKey = (options?: Options<ListGitProvidersData>) => createQueryKey('listGitProviders', options);

/**
 * List all git providers
 */
export const listGitProvidersOptions = (options?: Options<ListGitProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGitProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGitProvidersQueryKey(options)
    });
};

/**
 * Create a new git provider configuration
 */
export const createGitProviderMutation = (options?: Partial<Options<CreateGitProviderData>>): UseMutationOptions<CreateGitProviderResponse, DefaultError, Options<CreateGitProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateGitProviderResponse, DefaultError, Options<CreateGitProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGitProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a GitHub Personal Access Token provider
 */
export const createGithubPatProviderMutation = (options?: Partial<Options<CreateGithubPatProviderData>>): UseMutationOptions<CreateGithubPatProviderResponse, DefaultError, Options<CreateGithubPatProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateGithubPatProviderResponse, DefaultError, Options<CreateGithubPatProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGithubPatProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a GitLab OAuth provider
 */
export const createGitlabOauthProviderMutation = (options?: Partial<Options<CreateGitlabOauthProviderData>>): UseMutationOptions<CreateGitlabOauthProviderResponse, DefaultError, Options<CreateGitlabOauthProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateGitlabOauthProviderResponse, DefaultError, Options<CreateGitlabOauthProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGitlabOauthProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a GitLab PAT provider
 */
export const createGitlabPatProviderMutation = (options?: Partial<Options<CreateGitlabPatProviderData>>): UseMutationOptions<CreateGitlabPatProviderResponse, DefaultError, Options<CreateGitlabPatProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateGitlabPatProviderResponse, DefaultError, Options<CreateGitlabPatProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGitlabPatProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete a git provider
 */
export const deleteProvider3Mutation = (options?: Partial<Options<DeleteProvider3Data>>): UseMutationOptions<DeleteProvider3Response, DefaultError, Options<DeleteProvider3Data>> => {
    const mutationOptions: UseMutationOptions<DeleteProvider3Response, DefaultError, Options<DeleteProvider3Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProvider3({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGitProviderQueryKey = (options: Options<GetGitProviderData>) => createQueryKey('getGitProvider', options);

/**
 * Get a specific git provider
 */
export const getGitProviderOptions = (options: Options<GetGitProviderData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGitProvider({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGitProviderQueryKey(options)
    });
};

/**
 * Activate a git provider
 */
export const activateProviderMutation = (options?: Partial<Options<ActivateProviderData>>): UseMutationOptions<unknown, DefaultError, Options<ActivateProviderData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ActivateProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await activateProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const handleGitProviderOauthCallbackQueryKey = (options: Options<HandleGitProviderOauthCallbackData>) => createQueryKey('handleGitProviderOauthCallback', options);

/**
 * Handle OAuth callback for a git provider
 */
export const handleGitProviderOauthCallbackOptions = (options: Options<HandleGitProviderOauthCallbackData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await handleGitProviderOauthCallback({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: handleGitProviderOauthCallbackQueryKey(options)
    });
};

export const getProviderConnectionsQueryKey = (options: Options<GetProviderConnectionsData>) => createQueryKey('getProviderConnections', options);

/**
 * Get connections for a specific git provider
 */
export const getProviderConnectionsOptions = (options: Options<GetProviderConnectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProviderConnections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProviderConnectionsQueryKey(options)
    });
};

/**
 * Deactivate a git provider
 */
export const deactivateProviderMutation = (options?: Partial<Options<DeactivateProviderData>>): UseMutationOptions<unknown, DefaultError, Options<DeactivateProviderData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeactivateProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deactivateProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const checkProviderDeletionSafetyQueryKey = (options: Options<CheckProviderDeletionSafetyData>) => createQueryKey('checkProviderDeletionSafety', options);

/**
 * Check if a git provider can be safely deleted
 */
export const checkProviderDeletionSafetyOptions = (options: Options<CheckProviderDeletionSafetyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkProviderDeletionSafety({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkProviderDeletionSafetyQueryKey(options)
    });
};

export const startGitProviderOauthQueryKey = (options: Options<StartGitProviderOauthData>) => createQueryKey('startGitProviderOauth', options);

/**
 * Start OAuth flow for a git provider
 */
export const startGitProviderOauthOptions = (options: Options<StartGitProviderOauthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await startGitProviderOauth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: startGitProviderOauthQueryKey(options)
    });
};

/**
 * Safely delete a git provider (only if no projects are using it)
 */
export const deleteProviderSafelyMutation = (options?: Partial<Options<DeleteProviderSafelyData>>): UseMutationOptions<DeleteProviderSafelyResponse, DefaultError, Options<DeleteProviderSafelyData>> => {
    const mutationOptions: UseMutationOptions<DeleteProviderSafelyResponse, DefaultError, Options<DeleteProviderSafelyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProviderSafely({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicRepositoryQueryKey = (options: Options<GetPublicRepositoryData>) => createQueryKey('getPublicRepository', options);

/**
 * Get information about a public repository (supports GitHub and GitLab)
 */
export const getPublicRepositoryOptions = (options: Options<GetPublicRepositoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicRepository({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicRepositoryQueryKey(options)
    });
};

export const getPublicBranchesQueryKey = (options: Options<GetPublicBranchesData>) => createQueryKey('getPublicBranches', options);

/**
 * Get branches for a public repository (supports GitHub and GitLab)
 */
export const getPublicBranchesOptions = (options: Options<GetPublicBranchesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicBranches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicBranchesQueryKey(options)
    });
};

export const detectPublicPresetsQueryKey = (options: Options<DetectPublicPresetsData>) => createQueryKey('detectPublicPresets', options);

/**
 * Detect presets for a public repository (supports GitHub and GitLab)
 */
export const detectPublicPresetsOptions = (options: Options<DetectPublicPresetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectPublicPresets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectPublicPresetsQueryKey(options)
    });
};

/**
 * Discover workloads from a source
 */
export const discoverWorkloadsMutation = (options?: Partial<Options<DiscoverWorkloadsData>>): UseMutationOptions<DiscoverWorkloadsResponse, DefaultError, Options<DiscoverWorkloadsData>> => {
    const mutationOptions: UseMutationOptions<DiscoverWorkloadsResponse, DefaultError, Options<DiscoverWorkloadsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await discoverWorkloads({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Execute an import
 */
export const executeImportMutation = (options?: Partial<Options<ExecuteImportData>>): UseMutationOptions<ExecuteImportResponse, DefaultError, Options<ExecuteImportData>> => {
    const mutationOptions: UseMutationOptions<ExecuteImportResponse, DefaultError, Options<ExecuteImportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await executeImport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create an import plan
 */
export const createPlanMutation = (options?: Partial<Options<CreatePlanData>>): UseMutationOptions<CreatePlanResponse, DefaultError, Options<CreatePlanData>> => {
    const mutationOptions: UseMutationOptions<CreatePlanResponse, DefaultError, Options<CreatePlanData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPlan({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSourcesQueryKey = (options?: Options<ListSourcesData>) => createQueryKey('listSources', options);

/**
 * List available import sources
 */
export const listSourcesOptions = (options?: Options<ListSourcesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSources({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSourcesQueryKey(options)
    });
};

export const getImportStatusQueryKey = (options: Options<GetImportStatusData>) => createQueryKey('getImportStatus', options);

/**
 * Get import status
 */
export const getImportStatusOptions = (options: Options<GetImportStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getImportStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getImportStatusQueryKey(options)
    });
};

export const getIncidentQueryKey = (options: Options<GetIncidentData>) => createQueryKey('getIncident', options);

/**
 * Get an incident by ID
 */
export const getIncidentOptions = (options: Options<GetIncidentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIncident({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getIncidentQueryKey(options)
    });
};

/**
 * Update incident status
 */
export const updateIncidentStatusMutation = (options?: Partial<Options<UpdateIncidentStatusData>>): UseMutationOptions<UpdateIncidentStatusResponse, DefaultError, Options<UpdateIncidentStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateIncidentStatusResponse, DefaultError, Options<UpdateIncidentStatusData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateIncidentStatus({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getIncidentUpdatesQueryKey = (options: Options<GetIncidentUpdatesData>) => createQueryKey('getIncidentUpdates', options);

/**
 * Get incident updates
 */
export const getIncidentUpdatesOptions = (options: Options<GetIncidentUpdatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIncidentUpdates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getIncidentUpdatesQueryKey(options)
    });
};

export const listIpAccessControlQueryKey = (options?: Options<ListIpAccessControlData>) => createQueryKey('listIpAccessControl', options);

/**
 * List all IP access control rules
 */
export const listIpAccessControlOptions = (options?: Options<ListIpAccessControlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listIpAccessControl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listIpAccessControlQueryKey(options)
    });
};

/**
 * Create a new IP access control rule
 */
export const createIpAccessControlMutation = (options?: Partial<Options<CreateIpAccessControlData>>): UseMutationOptions<CreateIpAccessControlResponse, DefaultError, Options<CreateIpAccessControlData>> => {
    const mutationOptions: UseMutationOptions<CreateIpAccessControlResponse, DefaultError, Options<CreateIpAccessControlData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createIpAccessControl({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const checkIpBlockedQueryKey = (options: Options<CheckIpBlockedData>) => createQueryKey('checkIpBlocked', options);

/**
 * Check if an IP address is blocked
 */
export const checkIpBlockedOptions = (options: Options<CheckIpBlockedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkIpBlocked({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkIpBlockedQueryKey(options)
    });
};

/**
 * Delete an IP access control rule
 */
export const deleteIpAccessControlMutation = (options?: Partial<Options<DeleteIpAccessControlData>>): UseMutationOptions<DeleteIpAccessControlResponse, DefaultError, Options<DeleteIpAccessControlData>> => {
    const mutationOptions: UseMutationOptions<DeleteIpAccessControlResponse, DefaultError, Options<DeleteIpAccessControlData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteIpAccessControl({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getIpAccessControlQueryKey = (options: Options<GetIpAccessControlData>) => createQueryKey('getIpAccessControl', options);

/**
 * Get a single IP access control rule by ID
 */
export const getIpAccessControlOptions = (options: Options<GetIpAccessControlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIpAccessControl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getIpAccessControlQueryKey(options)
    });
};

/**
 * Update an IP access control rule
 */
export const updateIpAccessControlMutation = (options?: Partial<Options<UpdateIpAccessControlData>>): UseMutationOptions<UpdateIpAccessControlResponse, DefaultError, Options<UpdateIpAccessControlData>> => {
    const mutationOptions: UseMutationOptions<UpdateIpAccessControlResponse, DefaultError, Options<UpdateIpAccessControlData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateIpAccessControl({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete one or more keys
 */
export const kvDelMutation = (options?: Partial<Options<KvDelData>>): UseMutationOptions<KvDelResponse, DefaultError, Options<KvDelData>> => {
    const mutationOptions: UseMutationOptions<KvDelResponse, DefaultError, Options<KvDelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvDel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disable KV service
 */
export const kvDisableMutation = (options?: Partial<Options<KvDisableData>>): UseMutationOptions<KvDisableResponse, DefaultError, Options<KvDisableData>> => {
    const mutationOptions: UseMutationOptions<KvDisableResponse, DefaultError, Options<KvDisableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvDisable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable KV service
 */
export const kvEnableMutation = (options?: Partial<Options<KvEnableData>>): UseMutationOptions<KvEnableResponse, DefaultError, Options<KvEnableData>> => {
    const mutationOptions: UseMutationOptions<KvEnableResponse, DefaultError, Options<KvEnableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvEnable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set expiration on a key
 */
export const kvExpireMutation = (options?: Partial<Options<KvExpireData>>): UseMutationOptions<KvExpireResponse, DefaultError, Options<KvExpireData>> => {
    const mutationOptions: UseMutationOptions<KvExpireResponse, DefaultError, Options<KvExpireData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvExpire({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get a value by key
 */
export const kvGetMutation = (options?: Partial<Options<KvGetData>>): UseMutationOptions<KvGetResponse, DefaultError, Options<KvGetData>> => {
    const mutationOptions: UseMutationOptions<KvGetResponse, DefaultError, Options<KvGetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvGet({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Increment a numeric value
 */
export const kvIncrMutation = (options?: Partial<Options<KvIncrData>>): UseMutationOptions<KvIncrResponse, DefaultError, Options<KvIncrData>> => {
    const mutationOptions: UseMutationOptions<KvIncrResponse, DefaultError, Options<KvIncrData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvIncr({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get keys matching a pattern
 */
export const kvKeysMutation = (options?: Partial<Options<KvKeysData>>): UseMutationOptions<KvKeysResponse, DefaultError, Options<KvKeysData>> => {
    const mutationOptions: UseMutationOptions<KvKeysResponse, DefaultError, Options<KvKeysData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvKeys({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set a value with optional expiration
 */
export const kvSetMutation = (options?: Partial<Options<KvSetData>>): UseMutationOptions<KvSetResponse, DefaultError, Options<KvSetData>> => {
    const mutationOptions: UseMutationOptions<KvSetResponse, DefaultError, Options<KvSetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvSet({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const kvStatusQueryKey = (options?: Options<KvStatusData>) => createQueryKey('kvStatus', options);

/**
 * Get KV service status
 */
export const kvStatusOptions = (options?: Options<KvStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await kvStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: kvStatusQueryKey(options)
    });
};

/**
 * Get time-to-live for a key
 */
export const kvTtlMutation = (options?: Partial<Options<KvTtlData>>): UseMutationOptions<KvTtlResponse, DefaultError, Options<KvTtlData>> => {
    const mutationOptions: UseMutationOptions<KvTtlResponse, DefaultError, Options<KvTtlData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvTtl({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update KV service configuration
 */
export const kvUpdateMutation = (options?: Partial<Options<KvUpdateData>>): UseMutationOptions<KvUpdateResponse, DefaultError, Options<KvUpdateData>> => {
    const mutationOptions: UseMutationOptions<KvUpdateResponse, DefaultError, Options<KvUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await kvUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRoutesQueryKey = (options?: Options<ListRoutesData>) => createQueryKey('listRoutes', options);

export const listRoutesOptions = (options?: Options<ListRoutesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRoutes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRoutesQueryKey(options)
    });
};

export const createRouteMutation = (options?: Partial<Options<CreateRouteData>>): UseMutationOptions<CreateRouteResponse, DefaultError, Options<CreateRouteData>> => {
    const mutationOptions: UseMutationOptions<CreateRouteResponse, DefaultError, Options<CreateRouteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRoute({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteRouteMutation = (options?: Partial<Options<DeleteRouteData>>): UseMutationOptions<DeleteRouteResponse, DefaultError, Options<DeleteRouteData>> => {
    const mutationOptions: UseMutationOptions<DeleteRouteResponse, DefaultError, Options<DeleteRouteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRoute({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRouteQueryKey = (options: Options<GetRouteData>) => createQueryKey('getRoute', options);

export const getRouteOptions = (options: Options<GetRouteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRoute({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRouteQueryKey(options)
    });
};

export const updateRouteMutation = (options?: Partial<Options<UpdateRouteData>>): UseMutationOptions<UpdateRouteResponse, DefaultError, Options<UpdateRouteData>> => {
    const mutationOptions: UseMutationOptions<UpdateRouteResponse, DefaultError, Options<UpdateRouteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRoute({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<unknown, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LogoutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logout({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a monitor
 */
export const deleteMonitorMutation = (options?: Partial<Options<DeleteMonitorData>>): UseMutationOptions<DeleteMonitorResponse, DefaultError, Options<DeleteMonitorData>> => {
    const mutationOptions: UseMutationOptions<DeleteMonitorResponse, DefaultError, Options<DeleteMonitorData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMonitor({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMonitorQueryKey = (options: Options<GetMonitorData>) => createQueryKey('getMonitor', options);

/**
 * Get a monitor by ID
 */
export const getMonitorOptions = (options: Options<GetMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMonitorQueryKey(options)
    });
};

export const getBucketedStatusQueryKey = (options: Options<GetBucketedStatusData>) => createQueryKey('getBucketedStatus', options);

/**
 * Get bucketed status data for a monitor using TimescaleDB
 */
export const getBucketedStatusOptions = (options: Options<GetBucketedStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBucketedStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBucketedStatusQueryKey(options)
    });
};

export const getCurrentMonitorStatusQueryKey = (options: Options<GetCurrentMonitorStatusData>) => createQueryKey('getCurrentMonitorStatus', options);

/**
 * Get current status and uptime metrics for a monitor
 */
export const getCurrentMonitorStatusOptions = (options: Options<GetCurrentMonitorStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentMonitorStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentMonitorStatusQueryKey(options)
    });
};

export const getUptimeHistoryQueryKey = (options: Options<GetUptimeHistoryData>) => createQueryKey('getUptimeHistory', options);

/**
 * Get uptime history for a monitor
 */
export const getUptimeHistoryOptions = (options: Options<GetUptimeHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUptimeHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUptimeHistoryQueryKey(options)
    });
};

/**
 * Delete notification preferences
 */
export const deletePreferencesMutation = (options?: Partial<Options<DeletePreferencesData>>): UseMutationOptions<DeletePreferencesResponse, DefaultError, Options<DeletePreferencesData>> => {
    const mutationOptions: UseMutationOptions<DeletePreferencesResponse, DefaultError, Options<DeletePreferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePreferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPreferencesQueryKey = (options?: Options<GetPreferencesData>) => createQueryKey('getPreferences', options);

/**
 * Get notification preferences
 */
export const getPreferencesOptions = (options?: Options<GetPreferencesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPreferences({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPreferencesQueryKey(options)
    });
};

/**
 * Update notification preferences
 */
export const updatePreferencesMutation = (options?: Partial<Options<UpdatePreferencesData>>): UseMutationOptions<UpdatePreferencesResponse, DefaultError, Options<UpdatePreferencesData>> => {
    const mutationOptions: UseMutationOptions<UpdatePreferencesResponse, DefaultError, Options<UpdatePreferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePreferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listNotificationProvidersQueryKey = (options?: Options<ListNotificationProvidersData>) => createQueryKey('listNotificationProviders', options);

/**
 * List all notification providers
 */
export const listNotificationProvidersOptions = (options?: Options<ListNotificationProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listNotificationProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listNotificationProvidersQueryKey(options)
    });
};

/**
 * Create a new notification provider
 */
export const createNotificationProviderMutation = (options?: Partial<Options<CreateNotificationProviderData>>): UseMutationOptions<CreateNotificationProviderResponse, DefaultError, Options<CreateNotificationProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateNotificationProviderResponse, DefaultError, Options<CreateNotificationProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createNotificationProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new Email notification provider
 */
export const createEmailProviderMutation = (options?: Partial<Options<CreateEmailProviderData>>): UseMutationOptions<CreateEmailProviderResponse, DefaultError, Options<CreateEmailProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateEmailProviderResponse, DefaultError, Options<CreateEmailProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEmailProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update an Email notification provider
 */
export const updateEmailProviderMutation = (options?: Partial<Options<UpdateEmailProviderData>>): UseMutationOptions<UpdateEmailProviderResponse, DefaultError, Options<UpdateEmailProviderData>> => {
    const mutationOptions: UseMutationOptions<UpdateEmailProviderResponse, DefaultError, Options<UpdateEmailProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEmailProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new Slack notification provider
 */
export const createSlackProviderMutation = (options?: Partial<Options<CreateSlackProviderData>>): UseMutationOptions<CreateSlackProviderResponse, DefaultError, Options<CreateSlackProviderData>> => {
    const mutationOptions: UseMutationOptions<CreateSlackProviderResponse, DefaultError, Options<CreateSlackProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSlackProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a Slack notification provider
 */
export const updateSlackProviderMutation = (options?: Partial<Options<UpdateSlackProviderData>>): UseMutationOptions<UpdateSlackProviderResponse, DefaultError, Options<UpdateSlackProviderData>> => {
    const mutationOptions: UseMutationOptions<UpdateSlackProviderResponse, DefaultError, Options<UpdateSlackProviderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSlackProvider({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a notification provider
 */
export const deleteProvider4Mutation = (options?: Partial<Options<DeleteProvider4Data>>): UseMutationOptions<DeleteProvider4Response, DefaultError, Options<DeleteProvider4Data>> => {
    const mutationOptions: UseMutationOptions<DeleteProvider4Response, DefaultError, Options<DeleteProvider4Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProvider4({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationProviderQueryKey = (options: Options<GetNotificationProviderData>) => createQueryKey('getNotificationProvider', options);

/**
 * Get a single notification provider
 */
export const getNotificationProviderOptions = (options: Options<GetNotificationProviderData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationProvider({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationProviderQueryKey(options)
    });
};

/**
 * Update a notification provider
 */
export const updateProvider2Mutation = (options?: Partial<Options<UpdateProvider2Data>>): UseMutationOptions<UpdateProvider2Response, DefaultError, Options<UpdateProvider2Data>> => {
    const mutationOptions: UseMutationOptions<UpdateProvider2Response, DefaultError, Options<UpdateProvider2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProvider2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test a notification provider
 */
export const testProvider2Mutation = (options?: Partial<Options<TestProvider2Data>>): UseMutationOptions<TestProvider2Response, DefaultError, Options<TestProvider2Data>> => {
    const mutationOptions: UseMutationOptions<TestProvider2Response, DefaultError, Options<TestProvider2Data>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await testProvider2({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listOrdersQueryKey = (options?: Options<ListOrdersData>) => createQueryKey('listOrders', options);

/**
 * List all ACME orders
 */
export const listOrdersOptions = (options?: Options<ListOrdersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listOrders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listOrdersQueryKey(options)
    });
};

export const hasPerformanceMetricsQueryKey = (options: Options<HasPerformanceMetricsData>) => createQueryKey('hasPerformanceMetrics', options);

/**
 * Check if performance metrics exist for a project
 */
export const hasPerformanceMetricsOptions = (options: Options<HasPerformanceMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await hasPerformanceMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: hasPerformanceMetricsQueryKey(options)
    });
};

export const getPerformanceMetricsQueryKey = (options: Options<GetPerformanceMetricsData>) => createQueryKey('getPerformanceMetrics', options);

/**
 * Get performance metrics
 */
export const getPerformanceMetricsOptions = (options: Options<GetPerformanceMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPerformanceMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPerformanceMetricsQueryKey(options)
    });
};

export const getMetricsOverTimeQueryKey = (options: Options<GetMetricsOverTimeData>) => createQueryKey('getMetricsOverTime', options);

/**
 * Get metrics over time
 */
export const getMetricsOverTimeOptions = (options: Options<GetMetricsOverTimeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsOverTime({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsOverTimeQueryKey(options)
    });
};

export const getGroupedPageMetricsQueryKey = (options: Options<GetGroupedPageMetricsData>) => createQueryKey('getGroupedPageMetrics', options);

/**
 * Get grouped page metrics
 */
export const getGroupedPageMetricsOptions = (options: Options<GetGroupedPageMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupedPageMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupedPageMetricsQueryKey(options)
    });
};

export const getAccessInfoQueryKey = (options?: Options<GetAccessInfoData>) => createQueryKey('getAccessInfo', options);

/**
 * Get information about how the service is being accessed
 * Returns details about the server's access mode, public IP address, private IP address,
 * and domain creation capabilities. Both IP addresses are always included when available.
 */
export const getAccessInfoOptions = (options?: Options<GetAccessInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAccessInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAccessInfoQueryKey(options)
    });
};

export const getPrivateIpQueryKey = (options?: Options<GetPrivateIpData>) => createQueryKey('getPrivateIp', options);

/**
 * Get private/local IP address of the server
 */
export const getPrivateIpOptions = (options?: Options<GetPrivateIpData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPrivateIp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPrivateIpQueryKey(options)
    });
};

export const getPublicIpQueryKey = (options?: Options<GetPublicIpData>) => createQueryKey('getPublicIp', options);

/**
 * Get public IP address of the server
 */
export const getPublicIpOptions = (options?: Options<GetPublicIpData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicIp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicIpQueryKey(options)
    });
};

export const listPresetsQueryKey = (options?: Options<ListPresetsData>) => createQueryKey('listPresets', options);

/**
 * List all available presets
 */
export const listPresetsOptions = (options?: Options<ListPresetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPresets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPresetsQueryKey(options)
    });
};

export const getProjectsQueryKey = (options?: Options<GetProjectsData>) => createQueryKey('getProjects', options);

/**
 * Get a list of all projects
 */
export const getProjectsOptions = (options?: Options<GetProjectsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsQueryKey(options)
    });
};

export const getProjectsInfiniteQueryKey = (options?: Options<GetProjectsData>): QueryKey<Options<GetProjectsData>> => createQueryKey('getProjects', options, true);

/**
 * Get a list of all projects
 */
export const getProjectsInfiniteOptions = (options?: Options<GetProjectsData>) => {
    return infiniteQueryOptions<GetProjectsResponse, DefaultError, InfiniteData<GetProjectsResponse>, QueryKey<Options<GetProjectsData>>, number | Pick<QueryKey<Options<GetProjectsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetProjectsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getProjects({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsInfiniteQueryKey(options)
    });
};

/**
 * Create a new project
 */
export const createProjectMutation = (options?: Partial<Options<CreateProjectData>>): UseMutationOptions<CreateProjectResponse, DefaultError, Options<CreateProjectData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectResponse, DefaultError, Options<CreateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectBySlugQueryKey = (options: Options<GetProjectBySlugData>) => createQueryKey('getProjectBySlug', options);

/**
 * Get details of a specific project by slug
 */
export const getProjectBySlugOptions = (options: Options<GetProjectBySlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectBySlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectBySlugQueryKey(options)
    });
};

/**
 * Create a new project from a template
 * Creates a new repository from a template and sets up the project with the
 * specified configuration. The template is cloned to a new repository under
 * the authenticated user's account or specified organization.
 */
export const createProjectFromTemplateMutation = (options?: Partial<Options<CreateProjectFromTemplateData>>): UseMutationOptions<CreateProjectFromTemplateResponse, DefaultError, Options<CreateProjectFromTemplateData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectFromTemplateResponse, DefaultError, Options<CreateProjectFromTemplateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProjectFromTemplate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectStatisticsQueryKey = (options?: Options<GetProjectStatisticsData>) => createQueryKey('getProjectStatistics', options);

/**
 * Get project statistics
 */
export const getProjectStatisticsOptions = (options?: Options<GetProjectStatisticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectStatistics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectStatisticsQueryKey(options)
    });
};

export const deleteProjectMutation = (options?: Partial<Options<DeleteProjectData>>): UseMutationOptions<DeleteProjectResponse, DefaultError, Options<DeleteProjectData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectResponse, DefaultError, Options<DeleteProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectQueryKey = (options: Options<GetProjectData>) => createQueryKey('getProject', options);

/**
 * Get details of a specific project
 */
export const getProjectOptions = (options: Options<GetProjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectQueryKey(options)
    });
};

export const updateProjectMutation = (options?: Partial<Options<UpdateProjectData>>): UseMutationOptions<UpdateProjectResponse, DefaultError, Options<UpdateProjectData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectResponse, DefaultError, Options<UpdateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectDeploymentsQueryKey = (options: Options<GetProjectDeploymentsData>) => createQueryKey('getProjectDeployments', options);

export const getProjectDeploymentsOptions = (options: Options<GetProjectDeploymentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectDeployments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectDeploymentsQueryKey(options)
    });
};

export const getProjectDeploymentsInfiniteQueryKey = (options: Options<GetProjectDeploymentsData>): QueryKey<Options<GetProjectDeploymentsData>> => createQueryKey('getProjectDeployments', options, true);

export const getProjectDeploymentsInfiniteOptions = (options: Options<GetProjectDeploymentsData>) => {
    return infiniteQueryOptions<GetProjectDeploymentsResponse, DefaultError, InfiniteData<GetProjectDeploymentsResponse>, QueryKey<Options<GetProjectDeploymentsData>>, number | Pick<QueryKey<Options<GetProjectDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetProjectDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getProjectDeployments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectDeploymentsInfiniteQueryKey(options)
    });
};

export const getLastDeploymentQueryKey = (options: Options<GetLastDeploymentData>) => createQueryKey('getLastDeployment', options);

/**
 * Get the last deployment for a specific project
 */
export const getLastDeploymentOptions = (options: Options<GetLastDeploymentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLastDeployment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLastDeploymentQueryKey(options)
    });
};

/**
 * Trigger pipeline for a specific project
 */
export const triggerProjectPipelineMutation = (options?: Partial<Options<TriggerProjectPipelineData>>): UseMutationOptions<TriggerProjectPipelineResponse, DefaultError, Options<TriggerProjectPipelineData>> => {
    const mutationOptions: UseMutationOptions<TriggerProjectPipelineResponse, DefaultError, Options<TriggerProjectPipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerProjectPipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActiveVisitors2QueryKey = (options: Options<GetActiveVisitors2Data>) => createQueryKey('getActiveVisitors2', options);

/**
 * Get active visitors count
 */
export const getActiveVisitors2Options = (options: Options<GetActiveVisitors2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActiveVisitors2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActiveVisitors2QueryKey(options)
    });
};

export const getAggregatedBucketsQueryKey = (options: Options<GetAggregatedBucketsData>) => createQueryKey('getAggregatedBuckets', options);

/**
 * Get aggregated metrics by time bucket
 */
export const getAggregatedBucketsOptions = (options: Options<GetAggregatedBucketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAggregatedBuckets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAggregatedBucketsQueryKey(options)
    });
};

/**
 * Update automatic deployment setting for a project
 */
export const updateAutomaticDeployMutation = (options?: Partial<Options<UpdateAutomaticDeployData>>): UseMutationOptions<UpdateAutomaticDeployResponse, DefaultError, Options<UpdateAutomaticDeployData>> => {
    const mutationOptions: UseMutationOptions<UpdateAutomaticDeployResponse, DefaultError, Options<UpdateAutomaticDeployData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAutomaticDeploy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCustomDomainsForProjectQueryKey = (options: Options<ListCustomDomainsForProjectData>) => createQueryKey('listCustomDomainsForProject', options);

/**
 * List all custom domains for a project
 */
export const listCustomDomainsForProjectOptions = (options: Options<ListCustomDomainsForProjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCustomDomainsForProject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCustomDomainsForProjectQueryKey(options)
    });
};

/**
 * Create a custom domain for a project
 */
export const createCustomDomainMutation = (options?: Partial<Options<CreateCustomDomainData>>): UseMutationOptions<CreateCustomDomainResponse, DefaultError, Options<CreateCustomDomainData>> => {
    const mutationOptions: UseMutationOptions<CreateCustomDomainResponse, DefaultError, Options<CreateCustomDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCustomDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a custom domain
 */
export const deleteCustomDomainMutation = (options?: Partial<Options<DeleteCustomDomainData>>): UseMutationOptions<DeleteCustomDomainResponse, DefaultError, Options<DeleteCustomDomainData>> => {
    const mutationOptions: UseMutationOptions<DeleteCustomDomainResponse, DefaultError, Options<DeleteCustomDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCustomDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCustomDomainQueryKey = (options: Options<GetCustomDomainData>) => createQueryKey('getCustomDomain', options);

/**
 * Get a custom domain by ID
 */
export const getCustomDomainOptions = (options: Options<GetCustomDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCustomDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCustomDomainQueryKey(options)
    });
};

/**
 * Update a custom domain
 */
export const updateCustomDomainMutation = (options?: Partial<Options<UpdateCustomDomainData>>): UseMutationOptions<UpdateCustomDomainResponse, DefaultError, Options<UpdateCustomDomainData>> => {
    const mutationOptions: UseMutationOptions<UpdateCustomDomainResponse, DefaultError, Options<UpdateCustomDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCustomDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Link a custom domain to a certificate
 */
export const linkCustomDomainToCertificateMutation = (options?: Partial<Options<LinkCustomDomainToCertificateData>>): UseMutationOptions<LinkCustomDomainToCertificateResponse, DefaultError, Options<LinkCustomDomainToCertificateData>> => {
    const mutationOptions: UseMutationOptions<LinkCustomDomainToCertificateResponse, DefaultError, Options<LinkCustomDomainToCertificateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkCustomDomainToCertificate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update deployment configuration for a project
 */
export const updateProjectDeploymentConfigMutation = (options?: Partial<Options<UpdateProjectDeploymentConfigData>>): UseMutationOptions<UpdateProjectDeploymentConfigResponse, DefaultError, Options<UpdateProjectDeploymentConfigData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectDeploymentConfigResponse, DefaultError, Options<UpdateProjectDeploymentConfigData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProjectDeploymentConfig({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeploymentQueryKey = (options: Options<GetDeploymentData>) => createQueryKey('getDeployment', options);

/**
 * Get a specific deployment by ID for a project (identified by ID or slug)
 */
export const getDeploymentOptions = (options: Options<GetDeploymentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeployment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeploymentQueryKey(options)
    });
};

/**
 * Cancel a deployment
 */
export const cancelDeploymentMutation = (options?: Partial<Options<CancelDeploymentData>>): UseMutationOptions<CancelDeploymentResponse, DefaultError, Options<CancelDeploymentData>> => {
    const mutationOptions: UseMutationOptions<CancelDeploymentResponse, DefaultError, Options<CancelDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeploymentJobsQueryKey = (options: Options<GetDeploymentJobsData>) => createQueryKey('getDeploymentJobs', options);

/**
 * Get jobs for a specific deployment
 * Returns all jobs (workflow tasks) for a deployment, ordered by execution order.
 * This replaces the old deployment stages endpoint.
 */
export const getDeploymentJobsOptions = (options: Options<GetDeploymentJobsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeploymentJobs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeploymentJobsQueryKey(options)
    });
};

export const tailDeploymentJobLogsQueryKey = (options: Options<TailDeploymentJobLogsData>) => createQueryKey('tailDeploymentJobLogs', options);

/**
 * Tail logs for a specific deployment job in real-time via WebSocket
 * **WebSocket Streaming**: Logs are sent as raw text, one line per WebSocket message.
 *
 * **Authentication**: Requires authentication via session cookie (browser clients)
 * or API key (API clients). For browser-based WebSocket connections, ensure the user
 * is logged in - the browser automatically includes session cookies in the WebSocket
 * upgrade request.
 *
 * **API Client Authentication**: Include API key in Authorization header:
 * ```
 * Authorization: Bearer tk_your_api_key_here
 * ```
 */
export const tailDeploymentJobLogsOptions = (options: Options<TailDeploymentJobLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tailDeploymentJobLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tailDeploymentJobLogsQueryKey(options)
    });
};

export const getDeploymentOperationsQueryKey = (options: Options<GetDeploymentOperationsData>) => createQueryKey('getDeploymentOperations', options);

/**
 * Get all operations for a deployment
 */
export const getDeploymentOperationsOptions = (options: Options<GetDeploymentOperationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeploymentOperations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeploymentOperationsQueryKey(options)
    });
};

/**
 * Execute a deployment operation (deploy, mark_complete, take_screenshot)
 */
export const executeDeploymentOperationMutation = (options?: Partial<Options<ExecuteDeploymentOperationData>>): UseMutationOptions<ExecuteDeploymentOperationResponse, DefaultError, Options<ExecuteDeploymentOperationData>> => {
    const mutationOptions: UseMutationOptions<ExecuteDeploymentOperationResponse, DefaultError, Options<ExecuteDeploymentOperationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await executeDeploymentOperation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeploymentOperationStatusQueryKey = (options: Options<GetDeploymentOperationStatusData>) => createQueryKey('getDeploymentOperationStatus', options);

/**
 * Get the status of a specific operation type
 */
export const getDeploymentOperationStatusOptions = (options: Options<GetDeploymentOperationStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeploymentOperationStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeploymentOperationStatusQueryKey(options)
    });
};

/**
 * Pause a deployment
 */
export const pauseDeploymentMutation = (options?: Partial<Options<PauseDeploymentData>>): UseMutationOptions<PauseDeploymentResponse, DefaultError, Options<PauseDeploymentData>> => {
    const mutationOptions: UseMutationOptions<PauseDeploymentResponse, DefaultError, Options<PauseDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pauseDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resume a deployment
 */
export const resumeDeploymentMutation = (options?: Partial<Options<ResumeDeploymentData>>): UseMutationOptions<ResumeDeploymentResponse, DefaultError, Options<ResumeDeploymentData>> => {
    const mutationOptions: UseMutationOptions<ResumeDeploymentResponse, DefaultError, Options<ResumeDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resumeDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rollbackToDeploymentMutation = (options?: Partial<Options<RollbackToDeploymentData>>): UseMutationOptions<RollbackToDeploymentResponse, DefaultError, Options<RollbackToDeploymentData>> => {
    const mutationOptions: UseMutationOptions<RollbackToDeploymentResponse, DefaultError, Options<RollbackToDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rollbackToDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Teardown a specific deployment
 */
export const teardownDeploymentMutation = (options?: Partial<Options<TeardownDeploymentData>>): UseMutationOptions<TeardownDeploymentResponse, DefaultError, Options<TeardownDeploymentData>> => {
    const mutationOptions: UseMutationOptions<TeardownDeploymentResponse, DefaultError, Options<TeardownDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await teardownDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDsnsQueryKey = (options: Options<ListDsnsData>) => createQueryKey('listDsns', options);

/**
 * List all DSNs for a project
 */
export const listDsnsOptions = (options: Options<ListDsnsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDsns({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDsnsQueryKey(options)
    });
};

/**
 * Create a new DSN for a project
 */
export const createDsnMutation = (options?: Partial<Options<CreateDsnData>>): UseMutationOptions<CreateDsnResponse, DefaultError, Options<CreateDsnData>> => {
    const mutationOptions: UseMutationOptions<CreateDsnResponse, DefaultError, Options<CreateDsnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDsn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get or create DSN for a project/environment/deployment combination
 */
export const getOrCreateDsnMutation = (options?: Partial<Options<GetOrCreateDsnData>>): UseMutationOptions<GetOrCreateDsnResponse, DefaultError, Options<GetOrCreateDsnData>> => {
    const mutationOptions: UseMutationOptions<GetOrCreateDsnResponse, DefaultError, Options<GetOrCreateDsnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getOrCreateDsn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Regenerate DSN keys (rotate keys)
 */
export const regenerateDsnMutation = (options?: Partial<Options<RegenerateDsnData>>): UseMutationOptions<RegenerateDsnResponse, DefaultError, Options<RegenerateDsnData>> => {
    const mutationOptions: UseMutationOptions<RegenerateDsnResponse, DefaultError, Options<RegenerateDsnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await regenerateDsn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke (deactivate) a DSN
 */
export const revokeDsnMutation = (options?: Partial<Options<RevokeDsnData>>): UseMutationOptions<RevokeDsnResponse, DefaultError, Options<RevokeDsnData>> => {
    const mutationOptions: UseMutationOptions<RevokeDsnResponse, DefaultError, Options<RevokeDsnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await revokeDsn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEnvironmentVariablesQueryKey = (options: Options<GetEnvironmentVariablesData>) => createQueryKey('getEnvironmentVariables', options);

/**
 * Get environment variables for a project, optionally filtered by environment
 */
export const getEnvironmentVariablesOptions = (options: Options<GetEnvironmentVariablesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironmentVariables({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentVariablesQueryKey(options)
    });
};

/**
 * Create a new environment variable
 */
export const createEnvironmentVariableMutation = (options?: Partial<Options<CreateEnvironmentVariableData>>): UseMutationOptions<CreateEnvironmentVariableResponse, DefaultError, Options<CreateEnvironmentVariableData>> => {
    const mutationOptions: UseMutationOptions<CreateEnvironmentVariableResponse, DefaultError, Options<CreateEnvironmentVariableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEnvironmentVariable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEnvironmentVariableValueQueryKey = (options: Options<GetEnvironmentVariableValueData>) => createQueryKey('getEnvironmentVariableValue', options);

/**
 * Get environment variable value by key
 */
export const getEnvironmentVariableValueOptions = (options: Options<GetEnvironmentVariableValueData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironmentVariableValue({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentVariableValueQueryKey(options)
    });
};

/**
 * Delete an environment variable
 */
export const deleteEnvironmentVariableMutation = (options?: Partial<Options<DeleteEnvironmentVariableData>>): UseMutationOptions<DeleteEnvironmentVariableResponse, DefaultError, Options<DeleteEnvironmentVariableData>> => {
    const mutationOptions: UseMutationOptions<DeleteEnvironmentVariableResponse, DefaultError, Options<DeleteEnvironmentVariableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteEnvironmentVariable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update an environment variable
 */
export const updateEnvironmentVariableMutation = (options?: Partial<Options<UpdateEnvironmentVariableData>>): UseMutationOptions<UpdateEnvironmentVariableResponse, DefaultError, Options<UpdateEnvironmentVariableData>> => {
    const mutationOptions: UseMutationOptions<UpdateEnvironmentVariableResponse, DefaultError, Options<UpdateEnvironmentVariableData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEnvironmentVariable({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEnvironmentsQueryKey = (options: Options<GetEnvironmentsData>) => createQueryKey('getEnvironments', options);

/**
 * Get all environments for a project
 */
export const getEnvironmentsOptions = (options: Options<GetEnvironmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentsQueryKey(options)
    });
};

/**
 * Create a new environment for a project
 */
export const createEnvironmentMutation = (options?: Partial<Options<CreateEnvironmentData>>): UseMutationOptions<CreateEnvironmentResponse, DefaultError, Options<CreateEnvironmentData>> => {
    const mutationOptions: UseMutationOptions<CreateEnvironmentResponse, DefaultError, Options<CreateEnvironmentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEnvironment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an environment permanently
 * Permanently deletes an environment and all related data. Cannot delete:
 * - Production environments (name = "Production")
 *
 * Warning: This action is permanent and cannot be undone.
 * Active deployments are automatically cancelled before deletion.
 */
export const deleteEnvironmentMutation = (options?: Partial<Options<DeleteEnvironmentData>>): UseMutationOptions<DeleteEnvironmentResponse, DefaultError, Options<DeleteEnvironmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteEnvironmentResponse, DefaultError, Options<DeleteEnvironmentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteEnvironment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEnvironmentQueryKey = (options: Options<GetEnvironmentData>) => createQueryKey('getEnvironment', options);

/**
 * Get a specific environment by ID or slug
 */
export const getEnvironmentOptions = (options: Options<GetEnvironmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentQueryKey(options)
    });
};

export const getEnvironmentCronsQueryKey = (options: Options<GetEnvironmentCronsData>) => createQueryKey('getEnvironmentCrons', options);

export const getEnvironmentCronsOptions = (options: Options<GetEnvironmentCronsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironmentCrons({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentCronsQueryKey(options)
    });
};

export const getCronByIdQueryKey = (options: Options<GetCronByIdData>) => createQueryKey('getCronById', options);

export const getCronByIdOptions = (options: Options<GetCronByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCronById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCronByIdQueryKey(options)
    });
};

export const getCronExecutionsQueryKey = (options: Options<GetCronExecutionsData>) => createQueryKey('getCronExecutions', options);

export const getCronExecutionsOptions = (options: Options<GetCronExecutionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCronExecutions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCronExecutionsQueryKey(options)
    });
};

export const getCronExecutionsInfiniteQueryKey = (options: Options<GetCronExecutionsData>): QueryKey<Options<GetCronExecutionsData>> => createQueryKey('getCronExecutions', options, true);

export const getCronExecutionsInfiniteOptions = (options: Options<GetCronExecutionsData>) => {
    return infiniteQueryOptions<GetCronExecutionsResponse, DefaultError, InfiniteData<GetCronExecutionsResponse>, QueryKey<Options<GetCronExecutionsData>>, number | Pick<QueryKey<Options<GetCronExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCronExecutionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCronExecutions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCronExecutionsInfiniteQueryKey(options)
    });
};

export const getEnvironmentDomainsQueryKey = (options: Options<GetEnvironmentDomainsData>) => createQueryKey('getEnvironmentDomains', options);

/**
 * Get all environment domains for a specific environment
 */
export const getEnvironmentDomainsOptions = (options: Options<GetEnvironmentDomainsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnvironmentDomains({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEnvironmentDomainsQueryKey(options)
    });
};

/**
 * Add a new environment domain
 */
export const addEnvironmentDomainMutation = (options?: Partial<Options<AddEnvironmentDomainData>>): UseMutationOptions<AddEnvironmentDomainResponse, DefaultError, Options<AddEnvironmentDomainData>> => {
    const mutationOptions: UseMutationOptions<AddEnvironmentDomainResponse, DefaultError, Options<AddEnvironmentDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addEnvironmentDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an environment domain
 */
export const deleteEnvironmentDomainMutation = (options?: Partial<Options<DeleteEnvironmentDomainData>>): UseMutationOptions<DeleteEnvironmentDomainResponse, DefaultError, Options<DeleteEnvironmentDomainData>> => {
    const mutationOptions: UseMutationOptions<DeleteEnvironmentDomainResponse, DefaultError, Options<DeleteEnvironmentDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteEnvironmentDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update environment settings
 */
export const updateEnvironmentSettingsMutation = (options?: Partial<Options<UpdateEnvironmentSettingsData>>): UseMutationOptions<UpdateEnvironmentSettingsResponse, DefaultError, Options<UpdateEnvironmentSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateEnvironmentSettingsResponse, DefaultError, Options<UpdateEnvironmentSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEnvironmentSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Teardown an environment and all its active deployments
 */
export const teardownEnvironmentMutation = (options?: Partial<Options<TeardownEnvironmentData>>): UseMutationOptions<TeardownEnvironmentResponse, DefaultError, Options<TeardownEnvironmentData>> => {
    const mutationOptions: UseMutationOptions<TeardownEnvironmentResponse, DefaultError, Options<TeardownEnvironmentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await teardownEnvironment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getContainerLogsQueryKey = (options: Options<GetContainerLogsData>) => createQueryKey('getContainerLogs', options);

/**
 * Get logs for a container in an environment via WebSocket
 */
export const getContainerLogsOptions = (options: Options<GetContainerLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerLogsQueryKey(options)
    });
};

export const listContainersQueryKey = (options: Options<ListContainersData>) => createQueryKey('listContainers', options);

/**
 * List all containers for an environment
 */
export const listContainersOptions = (options: Options<ListContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listContainersQueryKey(options)
    });
};

export const getContainerDetailQueryKey = (options: Options<GetContainerDetailData>) => createQueryKey('getContainerDetail', options);

/**
 * Get detailed information about a specific container
 */
export const getContainerDetailOptions = (options: Options<GetContainerDetailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerDetail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerDetailQueryKey(options)
    });
};

export const getContainerLogsByIdQueryKey = (options: Options<GetContainerLogsByIdData>) => createQueryKey('getContainerLogsById', options);

/**
 * Get logs for a specific container by container ID via WebSocket
 */
export const getContainerLogsByIdOptions = (options: Options<GetContainerLogsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerLogsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerLogsByIdQueryKey(options)
    });
};

export const getContainerMetricsQueryKey = (options: Options<GetContainerMetricsData>) => createQueryKey('getContainerMetrics', options);

/**
 * Get metrics/stats for a specific container
 */
export const getContainerMetricsOptions = (options: Options<GetContainerMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerMetricsQueryKey(options)
    });
};

export const streamContainerMetricsQueryKey = (options: Options<StreamContainerMetricsData>) => createQueryKey('streamContainerMetrics', options);

/**
 * Stream container metrics via Server-Sent Events (SSE)
 */
export const streamContainerMetricsOptions = (options: Options<StreamContainerMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await streamContainerMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: streamContainerMetricsQueryKey(options)
    });
};

/**
 * Restart a container
 */
export const restartContainerMutation = (options?: Partial<Options<RestartContainerData>>): UseMutationOptions<RestartContainerResponse, DefaultError, Options<RestartContainerData>> => {
    const mutationOptions: UseMutationOptions<RestartContainerResponse, DefaultError, Options<RestartContainerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restartContainer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start a container
 */
export const startContainerMutation = (options?: Partial<Options<StartContainerData>>): UseMutationOptions<StartContainerResponse, DefaultError, Options<StartContainerData>> => {
    const mutationOptions: UseMutationOptions<StartContainerResponse, DefaultError, Options<StartContainerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await startContainer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Stop a specific container
 */
export const stopContainerMutation = (options?: Partial<Options<StopContainerData>>): UseMutationOptions<StopContainerResponse, DefaultError, Options<StopContainerData>> => {
    const mutationOptions: UseMutationOptions<StopContainerResponse, DefaultError, Options<StopContainerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await stopContainer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getErrorDashboardStatsQueryKey = (options: Options<GetErrorDashboardStatsData>) => createQueryKey('getErrorDashboardStats', options);

/**
 * Get error dashboard statistics
 */
export const getErrorDashboardStatsOptions = (options: Options<GetErrorDashboardStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getErrorDashboardStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getErrorDashboardStatsQueryKey(options)
    });
};

export const listErrorGroupsQueryKey = (options: Options<ListErrorGroupsData>) => createQueryKey('listErrorGroups', options);

/**
 * List error groups for a project
 */
export const listErrorGroupsOptions = (options: Options<ListErrorGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listErrorGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listErrorGroupsQueryKey(options)
    });
};

export const listErrorGroupsInfiniteQueryKey = (options: Options<ListErrorGroupsData>): QueryKey<Options<ListErrorGroupsData>> => createQueryKey('listErrorGroups', options, true);

/**
 * List error groups for a project
 */
export const listErrorGroupsInfiniteOptions = (options: Options<ListErrorGroupsData>) => {
    return infiniteQueryOptions<ListErrorGroupsResponse, DefaultError, InfiniteData<ListErrorGroupsResponse>, QueryKey<Options<ListErrorGroupsData>>, number | Pick<QueryKey<Options<ListErrorGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListErrorGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listErrorGroups({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listErrorGroupsInfiniteQueryKey(options)
    });
};

export const getErrorGroupQueryKey = (options: Options<GetErrorGroupData>) => createQueryKey('getErrorGroup', options);

/**
 * Get a specific error group
 */
export const getErrorGroupOptions = (options: Options<GetErrorGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getErrorGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getErrorGroupQueryKey(options)
    });
};

/**
 * Update error group status
 */
export const updateErrorGroupMutation = (options?: Partial<Options<UpdateErrorGroupData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateErrorGroupData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateErrorGroupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateErrorGroup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listErrorEventsQueryKey = (options: Options<ListErrorEventsData>) => createQueryKey('listErrorEvents', options);

/**
 * List error events for a specific group
 */
export const listErrorEventsOptions = (options: Options<ListErrorEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listErrorEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listErrorEventsQueryKey(options)
    });
};

export const listErrorEventsInfiniteQueryKey = (options: Options<ListErrorEventsData>): QueryKey<Options<ListErrorEventsData>> => createQueryKey('listErrorEvents', options, true);

/**
 * List error events for a specific group
 */
export const listErrorEventsInfiniteOptions = (options: Options<ListErrorEventsData>) => {
    return infiniteQueryOptions<ListErrorEventsResponse, DefaultError, InfiniteData<ListErrorEventsResponse>, QueryKey<Options<ListErrorEventsData>>, number | Pick<QueryKey<Options<ListErrorEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListErrorEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listErrorEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listErrorEventsInfiniteQueryKey(options)
    });
};

export const getErrorEventQueryKey = (options: Options<GetErrorEventData>) => createQueryKey('getErrorEvent', options);

/**
 * Get a specific error event
 */
export const getErrorEventOptions = (options: Options<GetErrorEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getErrorEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getErrorEventQueryKey(options)
    });
};

export const getErrorStatsQueryKey = (options: Options<GetErrorStatsData>) => createQueryKey('getErrorStats', options);

/**
 * Get error statistics for a project
 */
export const getErrorStatsOptions = (options: Options<GetErrorStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getErrorStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getErrorStatsQueryKey(options)
    });
};

export const getErrorTimeSeriesQueryKey = (options: Options<GetErrorTimeSeriesData>) => createQueryKey('getErrorTimeSeries', options);

/**
 * Get error time series data for charts
 */
export const getErrorTimeSeriesOptions = (options: Options<GetErrorTimeSeriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getErrorTimeSeries({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getErrorTimeSeriesQueryKey(options)
    });
};

export const getEventsCount2QueryKey = (options: Options<GetEventsCount2Data>) => createQueryKey('getEventsCount2', options);

/**
 * Get event counts with filtering
 */
export const getEventsCount2Options = (options: Options<GetEventsCount2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventsCount2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventsCount2QueryKey(options)
    });
};

export const getEventTypeBreakdownQueryKey = (options: Options<GetEventTypeBreakdownData>) => createQueryKey('getEventTypeBreakdown', options);

/**
 * Get event type breakdown
 */
export const getEventTypeBreakdownOptions = (options: Options<GetEventTypeBreakdownData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventTypeBreakdown({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventTypeBreakdownQueryKey(options)
    });
};

export const getPropertyBreakdownQueryKey = (options: Options<GetPropertyBreakdownData>) => createQueryKey('getPropertyBreakdown', options);

/**
 * Get property breakdown by grouping events by a column
 */
export const getPropertyBreakdownOptions = (options: Options<GetPropertyBreakdownData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPropertyBreakdown({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPropertyBreakdownQueryKey(options)
    });
};

export const getPropertyTimelineQueryKey = (options: Options<GetPropertyTimelineData>) => createQueryKey('getPropertyTimeline', options);

/**
 * Get property timeline by grouping events by a column over time
 */
export const getPropertyTimelineOptions = (options: Options<GetPropertyTimelineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPropertyTimeline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPropertyTimelineQueryKey(options)
    });
};

export const getEventsTimelineQueryKey = (options: Options<GetEventsTimelineData>) => createQueryKey('getEventsTimeline', options);

/**
 * Get events timeline
 */
export const getEventsTimelineOptions = (options: Options<GetEventsTimelineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventsTimeline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventsTimelineQueryKey(options)
    });
};

export const getUniqueEventsQueryKey = (options: Options<GetUniqueEventsData>) => createQueryKey('getUniqueEvents', options);

/**
 * Get all unique/distinct event types for a project
 */
export const getUniqueEventsOptions = (options: Options<GetUniqueEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUniqueEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUniqueEventsQueryKey(options)
    });
};

export const listFunnelsQueryKey = (options: Options<ListFunnelsData>) => createQueryKey('listFunnels', options);

/**
 * List all funnels for a project
 */
export const listFunnelsOptions = (options: Options<ListFunnelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listFunnels({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listFunnelsQueryKey(options)
    });
};

/**
 * Create a new funnel
 */
export const createFunnelMutation = (options?: Partial<Options<CreateFunnelData>>): UseMutationOptions<CreateFunnelResponse, DefaultError, Options<CreateFunnelData>> => {
    const mutationOptions: UseMutationOptions<CreateFunnelResponse, DefaultError, Options<CreateFunnelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFunnel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Preview funnel metrics without creating the funnel
 */
export const previewFunnelMetricsMutation = (options?: Partial<Options<PreviewFunnelMetricsData>>): UseMutationOptions<PreviewFunnelMetricsResponse, DefaultError, Options<PreviewFunnelMetricsData>> => {
    const mutationOptions: UseMutationOptions<PreviewFunnelMetricsResponse, DefaultError, Options<PreviewFunnelMetricsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await previewFunnelMetrics({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a funnel
 */
export const deleteFunnelMutation = (options?: Partial<Options<DeleteFunnelData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteFunnelData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteFunnelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFunnel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a funnel
 */
export const updateFunnelMutation = (options?: Partial<Options<UpdateFunnelData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateFunnelData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateFunnelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFunnel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFunnelMetricsQueryKey = (options: Options<GetFunnelMetricsData>) => createQueryKey('getFunnelMetrics', options);

/**
 * Get funnel metrics
 */
export const getFunnelMetricsOptions = (options: Options<GetFunnelMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFunnelMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFunnelMetricsQueryKey(options)
    });
};

/**
 * Update git settings for a project
 */
export const updateGitSettingsMutation = (options?: Partial<Options<UpdateGitSettingsData>>): UseMutationOptions<UpdateGitSettingsResponse, DefaultError, Options<UpdateGitSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateGitSettingsResponse, DefaultError, Options<UpdateGitSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateGitSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const hasErrorGroupsQueryKey = (options: Options<HasErrorGroupsData>) => createQueryKey('hasErrorGroups', options);

/**
 * Check if project has any error groups
 */
export const hasErrorGroupsOptions = (options: Options<HasErrorGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await hasErrorGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: hasErrorGroupsQueryKey(options)
    });
};

export const hasAnalyticsEventsQueryKey = (options: Options<HasAnalyticsEventsData>) => createQueryKey('hasAnalyticsEvents', options);

/**
 * Check if project has any analytics events
 */
export const hasAnalyticsEventsOptions = (options: Options<HasAnalyticsEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await hasAnalyticsEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: hasAnalyticsEventsQueryKey(options)
    });
};

export const getHourlyVisitsQueryKey = (options: Options<GetHourlyVisitsData>) => createQueryKey('getHourlyVisits', options);

/**
 * Get hourly visits
 */
export const getHourlyVisitsOptions = (options: Options<GetHourlyVisitsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHourlyVisits({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHourlyVisitsQueryKey(options)
    });
};

export const listExternalImagesQueryKey = (options: Options<ListExternalImagesData>) => createQueryKey('listExternalImages', options);

/**
 * List all external images for a project
 */
export const listExternalImagesOptions = (options: Options<ListExternalImagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listExternalImages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listExternalImagesQueryKey(options)
    });
};

/**
 * Push an external Docker image
 */
export const pushExternalImageMutation = (options?: Partial<Options<PushExternalImageData>>): UseMutationOptions<PushExternalImageResponse, DefaultError, Options<PushExternalImageData>> => {
    const mutationOptions: UseMutationOptions<PushExternalImageResponse, DefaultError, Options<PushExternalImageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pushExternalImage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getExternalImageQueryKey = (options: Options<GetExternalImageData>) => createQueryKey('getExternalImage', options);

/**
 * Get details of a specific external image
 */
export const getExternalImageOptions = (options: Options<GetExternalImageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getExternalImage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getExternalImageQueryKey(options)
    });
};

export const listIncidentsQueryKey = (options: Options<ListIncidentsData>) => createQueryKey('listIncidents', options);

/**
 * List incidents for a project
 */
export const listIncidentsOptions = (options: Options<ListIncidentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listIncidents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listIncidentsQueryKey(options)
    });
};

export const listIncidentsInfiniteQueryKey = (options: Options<ListIncidentsData>): QueryKey<Options<ListIncidentsData>> => createQueryKey('listIncidents', options, true);

/**
 * List incidents for a project
 */
export const listIncidentsInfiniteOptions = (options: Options<ListIncidentsData>) => {
    return infiniteQueryOptions<unknown, DefaultError, InfiniteData<unknown>, QueryKey<Options<ListIncidentsData>>, number | Pick<QueryKey<Options<ListIncidentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListIncidentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listIncidents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listIncidentsInfiniteQueryKey(options)
    });
};

/**
 * Create a new incident
 */
export const createIncidentMutation = (options?: Partial<Options<CreateIncidentData>>): UseMutationOptions<CreateIncidentResponse, DefaultError, Options<CreateIncidentData>> => {
    const mutationOptions: UseMutationOptions<CreateIncidentResponse, DefaultError, Options<CreateIncidentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createIncident({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBucketedIncidentsQueryKey = (options: Options<GetBucketedIncidentsData>) => createQueryKey('getBucketedIncidents', options);

/**
 * Get bucketed incident data for a project
 */
export const getBucketedIncidentsOptions = (options: Options<GetBucketedIncidentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBucketedIncidents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBucketedIncidentsQueryKey(options)
    });
};

export const listMonitorsQueryKey = (options: Options<ListMonitorsData>) => createQueryKey('listMonitors', options);

/**
 * List monitors for a project
 */
export const listMonitorsOptions = (options: Options<ListMonitorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMonitors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMonitorsQueryKey(options)
    });
};

/**
 * Create a new monitor
 */
export const createMonitorMutation = (options?: Partial<Options<CreateMonitorData>>): UseMutationOptions<CreateMonitorResponse, DefaultError, Options<CreateMonitorData>> => {
    const mutationOptions: UseMutationOptions<CreateMonitorResponse, DefaultError, Options<CreateMonitorData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createMonitor({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update project settings
 */
export const updateProjectSettingsMutation = (options?: Partial<Options<UpdateProjectSettingsData>>): UseMutationOptions<UpdateProjectSettingsResponse, DefaultError, Options<UpdateProjectSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectSettingsResponse, DefaultError, Options<UpdateProjectSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProjectSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStatusOverviewQueryKey = (options: Options<GetStatusOverviewData>) => createQueryKey('getStatusOverview', options);

/**
 * Get status page overview
 */
export const getStatusOverviewOptions = (options: Options<GetStatusOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatusOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStatusOverviewQueryKey(options)
    });
};

export const getUniqueCountsQueryKey = (options: Options<GetUniqueCountsData>) => createQueryKey('getUniqueCounts', options);

/**
 * Get unique counts over time frame
 */
export const getUniqueCountsOptions = (options: Options<GetUniqueCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUniqueCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUniqueCountsQueryKey(options)
    });
};

export const listProjectScansQueryKey = (options: Options<ListProjectScansData>) => createQueryKey('listProjectScans', options);

export const listProjectScansOptions = (options: Options<ListProjectScansData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listProjectScans({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProjectScansQueryKey(options)
    });
};

export const listProjectScansInfiniteQueryKey = (options: Options<ListProjectScansData>): QueryKey<Options<ListProjectScansData>> => createQueryKey('listProjectScans', options, true);

export const listProjectScansInfiniteOptions = (options: Options<ListProjectScansData>) => {
    return infiniteQueryOptions<ListProjectScansResponse, ListProjectScansError, InfiniteData<ListProjectScansResponse>, QueryKey<Options<ListProjectScansData>>, number | Pick<QueryKey<Options<ListProjectScansData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListProjectScansData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listProjectScans({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listProjectScansInfiniteQueryKey(options)
    });
};

export const triggerScanMutation = (options?: Partial<Options<TriggerScanData>>): UseMutationOptions<TriggerScanResponse, TriggerScanError, Options<TriggerScanData>> => {
    const mutationOptions: UseMutationOptions<TriggerScanResponse, TriggerScanError, Options<TriggerScanData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerScan({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLatestScansPerEnvironmentQueryKey = (options: Options<GetLatestScansPerEnvironmentData>) => createQueryKey('getLatestScansPerEnvironment', options);

export const getLatestScansPerEnvironmentOptions = (options: Options<GetLatestScansPerEnvironmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestScansPerEnvironment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestScansPerEnvironmentQueryKey(options)
    });
};

export const getLatestScanQueryKey = (options: Options<GetLatestScanData>) => createQueryKey('getLatestScan', options);

export const getLatestScanOptions = (options: Options<GetLatestScanData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestScan({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestScanQueryKey(options)
    });
};

export const listWebhooksQueryKey = (options: Options<ListWebhooksData>) => createQueryKey('listWebhooks', options);

/**
 * List all webhooks for a project
 */
export const listWebhooksOptions = (options: Options<ListWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksQueryKey(options)
    });
};

/**
 * Create a new webhook
 */
export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a webhook
 */
export const deleteWebhookMutation = (options?: Partial<Options<DeleteWebhookData>>): UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> => {
    const mutationOptions: UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

/**
 * Get a specific webhook
 */
export const getWebhookOptions = (options: Options<GetWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookQueryKey(options)
    });
};

/**
 * Update a webhook
 */
export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDeliveriesQueryKey = (options: Options<ListDeliveriesData>) => createQueryKey('listDeliveries', options);

/**
 * List webhook deliveries
 */
export const listDeliveriesOptions = (options: Options<ListDeliveriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDeliveries({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDeliveriesQueryKey(options)
    });
};

export const getDeliveryQueryKey = (options: Options<GetDeliveryData>) => createQueryKey('getDelivery', options);

/**
 * Get a specific webhook delivery by ID
 */
export const getDeliveryOptions = (options: Options<GetDeliveryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDelivery({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeliveryQueryKey(options)
    });
};

/**
 * Retry a failed delivery
 */
export const retryDeliveryMutation = (options?: Partial<Options<RetryDeliveryData>>): UseMutationOptions<RetryDeliveryResponse, DefaultError, Options<RetryDeliveryData>> => {
    const mutationOptions: UseMutationOptions<RetryDeliveryResponse, DefaultError, Options<RetryDeliveryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await retryDelivery({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProxyLogsQueryKey = (options?: Options<GetProxyLogsData>) => createQueryKey('getProxyLogs', options);

/**
 * Get proxy logs with optional filters and pagination
 */
export const getProxyLogsOptions = (options?: Options<GetProxyLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProxyLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProxyLogsQueryKey(options)
    });
};

export const getProxyLogsInfiniteQueryKey = (options?: Options<GetProxyLogsData>): QueryKey<Options<GetProxyLogsData>> => createQueryKey('getProxyLogs', options, true);

/**
 * Get proxy logs with optional filters and pagination
 */
export const getProxyLogsInfiniteOptions = (options?: Options<GetProxyLogsData>) => {
    return infiniteQueryOptions<GetProxyLogsResponse, DefaultError, InfiniteData<GetProxyLogsResponse>, QueryKey<Options<GetProxyLogsData>>, number | null | Pick<QueryKey<Options<GetProxyLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetProxyLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getProxyLogs({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProxyLogsInfiniteQueryKey(options)
    });
};

export const getProxyLogByRequestIdQueryKey = (options: Options<GetProxyLogByRequestIdData>) => createQueryKey('getProxyLogByRequestId', options);

/**
 * Get a proxy log by request ID (for tracing)
 */
export const getProxyLogByRequestIdOptions = (options: Options<GetProxyLogByRequestIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProxyLogByRequestId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProxyLogByRequestIdQueryKey(options)
    });
};

export const getTimeBucketStatsQueryKey = (options: Options<GetTimeBucketStatsData>) => createQueryKey('getTimeBucketStats', options);

/**
 * Get time-bucketed statistics with optional filters
 */
export const getTimeBucketStatsOptions = (options: Options<GetTimeBucketStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimeBucketStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimeBucketStatsQueryKey(options)
    });
};

export const getTodayStatsQueryKey = (options?: Options<GetTodayStatsData>) => createQueryKey('getTodayStats', options);

/**
 * Get today's request count with optional filters
 */
export const getTodayStatsOptions = (options?: Options<GetTodayStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTodayStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTodayStatsQueryKey(options)
    });
};

export const getProxyLogByIdQueryKey = (options: Options<GetProxyLogByIdData>) => createQueryKey('getProxyLogById', options);

/**
 * Get a single proxy log by ID
 */
export const getProxyLogByIdOptions = (options: Options<GetProxyLogByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProxyLogById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProxyLogByIdQueryKey(options)
    });
};

export const listSyncedRepositoriesQueryKey = (options?: Options<ListSyncedRepositoriesData>) => createQueryKey('listSyncedRepositories', options);

/**
 * List synced repositories with advanced filtering
 * Lists repositories that have been synced to the database with filtering options.
 * This provides fast access to repository metadata with filtering by connection, search, and other criteria.
 */
export const listSyncedRepositoriesOptions = (options?: Options<ListSyncedRepositoriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSyncedRepositories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSyncedRepositoriesQueryKey(options)
    });
};

export const listSyncedRepositoriesInfiniteQueryKey = (options?: Options<ListSyncedRepositoriesData>): QueryKey<Options<ListSyncedRepositoriesData>> => createQueryKey('listSyncedRepositories', options, true);

/**
 * List synced repositories with advanced filtering
 * Lists repositories that have been synced to the database with filtering options.
 * This provides fast access to repository metadata with filtering by connection, search, and other criteria.
 */
export const listSyncedRepositoriesInfiniteOptions = (options?: Options<ListSyncedRepositoriesData>) => {
    return infiniteQueryOptions<ListSyncedRepositoriesResponse, DefaultError, InfiniteData<ListSyncedRepositoriesResponse>, QueryKey<Options<ListSyncedRepositoriesData>>, number | Pick<QueryKey<Options<ListSyncedRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSyncedRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSyncedRepositories({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSyncedRepositoriesInfiniteQueryKey(options)
    });
};

export const getRepositoryByNameQueryKey = (options: Options<GetRepositoryByNameData>) => createQueryKey('getRepositoryByName', options);

/**
 * Get repository by owner and name from any connection
 */
export const getRepositoryByNameOptions = (options: Options<GetRepositoryByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoryByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoryByNameQueryKey(options)
    });
};

export const getAllRepositoriesByNameQueryKey = (options: Options<GetAllRepositoriesByNameData>) => createQueryKey('getAllRepositoriesByName', options);

/**
 * Get all repositories with same owner/name from all git providers
 */
export const getAllRepositoriesByNameOptions = (options: Options<GetAllRepositoriesByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllRepositoriesByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllRepositoriesByNameQueryKey(options)
    });
};

export const getRepositoryPresetByNameQueryKey = (options: Options<GetRepositoryPresetByNameData>) => createQueryKey('getRepositoryPresetByName', options);

/**
 * Get repository preset by owner and name
 */
export const getRepositoryPresetByNameOptions = (options: Options<GetRepositoryPresetByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoryPresetByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoryPresetByNameQueryKey(options)
    });
};

export const getRepositoryBranchesQueryKey = (options: Options<GetRepositoryBranchesData>) => createQueryKey('getRepositoryBranches', options);

/**
 * Get repository branches
 */
export const getRepositoryBranchesOptions = (options: Options<GetRepositoryBranchesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoryBranches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoryBranchesQueryKey(options)
    });
};

export const getRepositoryTagsQueryKey = (options: Options<GetRepositoryTagsData>) => createQueryKey('getRepositoryTags', options);

/**
 * Get repository tags
 */
export const getRepositoryTagsOptions = (options: Options<GetRepositoryTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoryTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoryTagsQueryKey(options)
    });
};

export const getRepositoryPresetLiveQueryKey = (options: Options<GetRepositoryPresetLiveData>) => createQueryKey('getRepositoryPresetLive', options);

export const getRepositoryPresetLiveOptions = (options: Options<GetRepositoryPresetLiveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoryPresetLive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoryPresetLiveQueryKey(options)
    });
};

export const getBranchesByRepositoryIdQueryKey = (options: Options<GetBranchesByRepositoryIdData>) => createQueryKey('getBranchesByRepositoryId', options);

/**
 * Get repository branches by repository ID
 */
export const getBranchesByRepositoryIdOptions = (options: Options<GetBranchesByRepositoryIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBranchesByRepositoryId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBranchesByRepositoryIdQueryKey(options)
    });
};

export const checkCommitExistsQueryKey = (options: Options<CheckCommitExistsData>) => createQueryKey('checkCommitExists', options);

/**
 * Check if a commit exists in a repository
 */
export const checkCommitExistsOptions = (options: Options<CheckCommitExistsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkCommitExists({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkCommitExistsQueryKey(options)
    });
};

export const getTagsByRepositoryIdQueryKey = (options: Options<GetTagsByRepositoryIdData>) => createQueryKey('getTagsByRepositoryId', options);

/**
 * Get repository tags by repository ID
 */
export const getTagsByRepositoryIdOptions = (options: Options<GetTagsByRepositoryIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagsByRepositoryId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsByRepositoryIdQueryKey(options)
    });
};

export const getProjectSessionReplaysQueryKey = (options: Options<GetProjectSessionReplaysData>) => createQueryKey('getProjectSessionReplays', options);

/**
 * Get session replays for a project
 */
export const getProjectSessionReplaysOptions = (options: Options<GetProjectSessionReplaysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectSessionReplays({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectSessionReplaysQueryKey(options)
    });
};

export const getProjectSessionReplaysInfiniteQueryKey = (options: Options<GetProjectSessionReplaysData>): QueryKey<Options<GetProjectSessionReplaysData>> => createQueryKey('getProjectSessionReplays', options, true);

/**
 * Get session replays for a project
 */
export const getProjectSessionReplaysInfiniteOptions = (options: Options<GetProjectSessionReplaysData>) => {
    return infiniteQueryOptions<GetProjectSessionReplaysResponse, GetProjectSessionReplaysError, InfiniteData<GetProjectSessionReplaysResponse>, QueryKey<Options<GetProjectSessionReplaysData>>, number | Pick<QueryKey<Options<GetProjectSessionReplaysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetProjectSessionReplaysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getProjectSessionReplays({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectSessionReplaysInfiniteQueryKey(options)
    });
};

export const getSessionEvents2QueryKey = (options: Options<GetSessionEvents2Data>) => createQueryKey('getSessionEvents2', options);

/**
 * Get events for a specific session
 */
export const getSessionEvents2Options = (options: Options<GetSessionEvents2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionEvents2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionEvents2QueryKey(options)
    });
};

export const getSettingsQueryKey = (options?: Options<GetSettingsData>) => createQueryKey('getSettings', options);

/**
 * Get application settings
 */
export const getSettingsOptions = (options?: Options<GetSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsQueryKey(options)
    });
};

/**
 * Update application settings
 */
export const updateSettingsMutation = (options?: Partial<Options<UpdateSettingsData>>): UseMutationOptions<UpdateSettingsResponse, DefaultError, Options<UpdateSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateSettingsResponse, DefaultError, Options<UpdateSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTemplatesQueryKey = (options?: Options<ListTemplatesData>) => createQueryKey('listTemplates', options);

/**
 * List all available templates
 * Returns a list of all public templates, optionally filtered by tag or featured status.
 */
export const listTemplatesOptions = (options?: Options<ListTemplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTemplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTemplatesQueryKey(options)
    });
};

export const listTemplateTagsQueryKey = (options?: Options<ListTemplateTagsData>) => createQueryKey('listTemplateTags', options);

/**
 * List all available template tags
 * Returns a list of all unique tags used by public templates.
 */
export const listTemplateTagsOptions = (options?: Options<ListTemplateTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTemplateTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTemplateTagsQueryKey(options)
    });
};

export const getTemplateQueryKey = (options: Options<GetTemplateData>) => createQueryKey('getTemplate', options);

/**
 * Get a specific template by slug
 * Returns detailed information about a single template.
 */
export const getTemplateOptions = (options: Options<GetTemplateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTemplate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTemplateQueryKey(options)
    });
};

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) => createQueryKey('getCurrentUser', options);

export const getCurrentUserOptions = (options?: Options<GetCurrentUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserQueryKey(options)
    });
};

export const listUsersQueryKey = (options: Options<ListUsersData>) => createQueryKey('listUsers', options);

export const listUsersOptions = (options: Options<ListUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listUsersQueryKey(options)
    });
};

/**
 * Create a new user with roles
 */
export const createUserMutation = (options?: Partial<Options<CreateUserData>>): UseMutationOptions<CreateUserResponse, DefaultError, Options<CreateUserData>> => {
    const mutationOptions: UseMutationOptions<CreateUserResponse, DefaultError, Options<CreateUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update current user's information
 */
export const updateSelfMutation = (options?: Partial<Options<UpdateSelfData>>): UseMutationOptions<UpdateSelfResponse, DefaultError, Options<UpdateSelfData>> => {
    const mutationOptions: UseMutationOptions<UpdateSelfResponse, DefaultError, Options<UpdateSelfData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSelf({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const disableMfaMutation = (options?: Partial<Options<DisableMfaData>>): UseMutationOptions<DisableMfaResponse, DefaultError, Options<DisableMfaData>> => {
    const mutationOptions: UseMutationOptions<DisableMfaResponse, DefaultError, Options<DisableMfaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await disableMfa({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setupMfaMutation = (options?: Partial<Options<SetupMfaData>>): UseMutationOptions<SetupMfaResponse, DefaultError, Options<SetupMfaData>> => {
    const mutationOptions: UseMutationOptions<SetupMfaResponse, DefaultError, Options<SetupMfaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setupMfa({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyAndEnableMfaMutation = (options?: Partial<Options<VerifyAndEnableMfaData>>): UseMutationOptions<VerifyAndEnableMfaResponse, DefaultError, Options<VerifyAndEnableMfaData>> => {
    const mutationOptions: UseMutationOptions<VerifyAndEnableMfaResponse, DefaultError, Options<VerifyAndEnableMfaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await verifyAndEnableMfa({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<DeleteUserResponse, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update user information (admin only)
 */
export const updateUserMutation = (options?: Partial<Options<UpdateUserData>>): UseMutationOptions<UpdateUserResponse, DefaultError, Options<UpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserResponse, DefaultError, Options<UpdateUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restoreUserMutation = (options?: Partial<Options<RestoreUserData>>): UseMutationOptions<RestoreUserResponse, DefaultError, Options<RestoreUserData>> => {
    const mutationOptions: UseMutationOptions<RestoreUserResponse, DefaultError, Options<RestoreUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restoreUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<unknown, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await assignRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeRoleMutation = (options?: Partial<Options<RemoveRoleData>>): UseMutationOptions<RemoveRoleResponse, DefaultError, Options<RemoveRoleData>> => {
    const mutationOptions: UseMutationOptions<RemoveRoleResponse, DefaultError, Options<RemoveRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVisitorSessions2QueryKey = (options: Options<GetVisitorSessions2Data>) => createQueryKey('getVisitorSessions2', options);

/**
 * Get session replays for a visitor
 */
export const getVisitorSessions2Options = (options: Options<GetVisitorSessions2Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVisitorSessions2({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorSessions2QueryKey(options)
    });
};

export const getVisitorSessions2InfiniteQueryKey = (options: Options<GetVisitorSessions2Data>): QueryKey<Options<GetVisitorSessions2Data>> => createQueryKey('getVisitorSessions2', options, true);

/**
 * Get session replays for a visitor
 */
export const getVisitorSessions2InfiniteOptions = (options: Options<GetVisitorSessions2Data>) => {
    return infiniteQueryOptions<GetVisitorSessions2Response, GetVisitorSessions2Error, InfiniteData<GetVisitorSessions2Response>, QueryKey<Options<GetVisitorSessions2Data>>, number | Pick<QueryKey<Options<GetVisitorSessions2Data>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetVisitorSessions2Data>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getVisitorSessions2({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVisitorSessions2InfiniteQueryKey(options)
    });
};

/**
 * Delete a session replay
 */
export const deleteSessionReplayMutation = (options?: Partial<Options<DeleteSessionReplayData>>): UseMutationOptions<unknown, DeleteSessionReplayError, Options<DeleteSessionReplayData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteSessionReplayError, Options<DeleteSessionReplayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSessionReplay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionReplayQueryKey = (options: Options<GetSessionReplayData>) => createQueryKey('getSessionReplay', options);

/**
 * Get session replay data with visitor info (without events)
 */
export const getSessionReplayOptions = (options: Options<GetSessionReplayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionReplay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionReplayQueryKey(options)
    });
};

/**
 * Update session duration
 */
export const updateSessionDurationMutation = (options?: Partial<Options<UpdateSessionDurationData>>): UseMutationOptions<UpdateSessionDurationResponse, UpdateSessionDurationError, Options<UpdateSessionDurationData>> => {
    const mutationOptions: UseMutationOptions<UpdateSessionDurationResponse, UpdateSessionDurationError, Options<UpdateSessionDurationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSessionDuration({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionReplayEventsQueryKey = (options: Options<GetSessionReplayEventsData>) => createQueryKey('getSessionReplayEvents', options);

/**
 * Get session replay events (with session and visitor metadata)
 */
export const getSessionReplayEventsOptions = (options: Options<GetSessionReplayEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionReplayEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionReplayEventsQueryKey(options)
    });
};

/**
 * Add events to an existing session
 */
export const addEventsMutation = (options?: Partial<Options<AddEventsData>>): UseMutationOptions<AddEventsResponse, AddEventsError, Options<AddEventsData>> => {
    const mutationOptions: UseMutationOptions<AddEventsResponse, AddEventsError, Options<AddEventsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addEvents({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteScanMutation = (options?: Partial<Options<DeleteScanData>>): UseMutationOptions<DeleteScanResponse, DeleteScanError, Options<DeleteScanData>> => {
    const mutationOptions: UseMutationOptions<DeleteScanResponse, DeleteScanError, Options<DeleteScanData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteScan({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScanQueryKey = (options: Options<GetScanData>) => createQueryKey('getScan', options);

export const getScanOptions = (options: Options<GetScanData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScan({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScanQueryKey(options)
    });
};

export const getScanVulnerabilitiesQueryKey = (options: Options<GetScanVulnerabilitiesData>) => createQueryKey('getScanVulnerabilities', options);

export const getScanVulnerabilitiesOptions = (options: Options<GetScanVulnerabilitiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScanVulnerabilities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScanVulnerabilitiesQueryKey(options)
    });
};

export const getScanVulnerabilitiesInfiniteQueryKey = (options: Options<GetScanVulnerabilitiesData>): QueryKey<Options<GetScanVulnerabilitiesData>> => createQueryKey('getScanVulnerabilities', options, true);

export const getScanVulnerabilitiesInfiniteOptions = (options: Options<GetScanVulnerabilitiesData>) => {
    return infiniteQueryOptions<GetScanVulnerabilitiesResponse, GetScanVulnerabilitiesError, InfiniteData<GetScanVulnerabilitiesResponse>, QueryKey<Options<GetScanVulnerabilitiesData>>, number | Pick<QueryKey<Options<GetScanVulnerabilitiesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetScanVulnerabilitiesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getScanVulnerabilities({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScanVulnerabilitiesInfiniteQueryKey(options)
    });
};

export const listEventTypesQueryKey = (options?: Options<ListEventTypesData>) => createQueryKey('listEventTypes', options);

/**
 * List available event types
 */
export const listEventTypesOptions = (options?: Options<ListEventTypesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEventTypes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventTypesQueryKey(options)
    });
};

/**
 * Trigger weekly digest generation manually
 */
export const triggerWeeklyDigestMutation = (options?: Partial<Options<TriggerWeeklyDigestData>>): UseMutationOptions<TriggerWeeklyDigestResponse, DefaultError, Options<TriggerWeeklyDigestData>> => {
    const mutationOptions: UseMutationOptions<TriggerWeeklyDigestResponse, DefaultError, Options<TriggerWeeklyDigestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerWeeklyDigest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAuditLogsQueryKey = (options: Options<ListAuditLogsData>) => createQueryKey('listAuditLogs', options);

/**
 * List audit logs with optional filtering
 */
export const listAuditLogsOptions = (options: Options<ListAuditLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAuditLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAuditLogsQueryKey(options)
    });
};

export const listAuditLogsInfiniteQueryKey = (options: Options<ListAuditLogsData>): QueryKey<Options<ListAuditLogsData>> => createQueryKey('listAuditLogs', options, true);

/**
 * List audit logs with optional filtering
 */
export const listAuditLogsInfiniteOptions = (options: Options<ListAuditLogsData>) => {
    return infiniteQueryOptions<ListAuditLogsResponse, DefaultError, InfiniteData<ListAuditLogsResponse>, QueryKey<Options<ListAuditLogsData>>, unknown | Pick<QueryKey<Options<ListAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listAuditLogs({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAuditLogsInfiniteQueryKey(options)
    });
};

export const getAuditLogQueryKey = (options: Options<GetAuditLogData>) => createQueryKey('getAuditLog', options);

/**
 * Get a specific audit log entry by ID
 */
export const getAuditLogOptions = (options: Options<GetAuditLogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuditLog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuditLogQueryKey(options)
    });
};
