//! Framework detection for Node.js projects
//!
//! This module detects the framework used in a Node.js project by analyzing
//! package.json dependencies and devDependencies.

use serde::Deserialize;
use std::fs;
use std::path::Path;
use tracing::{debug, warn};

/// Supported Node.js frameworks
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeFramework {
    Astro,
    NextJs,
    NestJs,
    Nuxt,
    Remix,
    Vite,
    Vue,
    Express,
    Generic,
}

impl NodeFramework {
    /// Get the framework name
    pub fn name(&self) -> &'static str {
        match self {
            Self::Astro => "Astro",
            Self::NextJs => "Next.js",
            Self::NestJs => "NestJS",
            Self::Nuxt => "Nuxt",
            Self::Remix => "Remix",
            Self::Vite => "Vite",
            Self::Vue => "Vue",
            Self::Express => "Express",
            Self::Generic => "Generic Node.js",
        }
    }

    /// Generate nixpacks.toml configuration for this framework
    ///
    /// Returns the content of nixpacks.toml that will be written to the project directory
    /// before building. This overrides nixpacks' default behavior with framework-specific
    /// optimizations.
    pub fn nixpacks_config(&self) -> Option<String> {
        match self {
            Self::Astro => Some(
                r#"# Astro framework configuration
# Generated by Temps for optimal Astro deployment

[start]
# Astro requires --host 0.0.0.0 to bind to all network interfaces
# This allows external access to the preview server in containerized environments
cmd = "npm run preview -- --host 0.0.0.0"

[variables]
HOST = "0.0.0.0"
"#
                .to_string(),
            ),
            Self::Vite => Some(
                r#"# Vite framework configuration
# Generated by Temps for optimal Vite deployment

[start]
# Vite preview server with host binding for container access
cmd = "npm run preview -- --host 0.0.0.0 --port $PORT"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
"#
                .to_string(),
            ),
            Self::NextJs => {
                // Next.js works well with default nixpacks, no override needed
                // It uses standalone output which is already optimized
                None
            }
            Self::NestJs => Some(
                r#"# NestJS framework configuration
# Generated by Temps for optimal NestJS deployment

[start]
cmd = "node dist/main.js"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
"#
                .to_string(),
            ),
            Self::Nuxt => Some(
                r#"# Nuxt framework configuration
# Generated by Temps for optimal Nuxt deployment

[start]
# Nuxt 3 uses .output/server/index.mjs
cmd = "node .output/server/index.mjs"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
NITRO_HOST = "0.0.0.0"
NITRO_PORT = "3000"
"#
                .to_string(),
            ),
            Self::Remix => Some(
                r#"# Remix framework configuration
# Generated by Temps for optimal Remix deployment

[start]
cmd = "npm run start"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
"#
                .to_string(),
            ),
            Self::Vue => Some(
                r#"# Vue framework configuration
# Generated by Temps for optimal Vue deployment

[start]
cmd = "npm run preview -- --host 0.0.0.0 --port $PORT"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
"#
                .to_string(),
            ),
            Self::Express => Some(
                r#"# Express framework configuration
# Generated by Temps for optimal Express deployment

[start]
cmd = "node server.js"

[variables]
HOST = "0.0.0.0"
PORT = "3000"
"#
                .to_string(),
            ),
            Self::Generic => {
                // Generic Node.js - let nixpacks handle it
                None
            }
        }
    }
}

/// Simplified package.json structure for framework detection
#[derive(Debug, Deserialize)]
struct PackageJson {
    dependencies: Option<std::collections::HashMap<String, String>>,
    #[serde(rename = "devDependencies")]
    dev_dependencies: Option<std::collections::HashMap<String, String>>,
}

impl PackageJson {
    /// Check if a dependency exists in either dependencies or devDependencies
    fn has_dependency(&self, name: &str) -> bool {
        self.dependencies
            .as_ref()
            .map(|deps| deps.contains_key(name))
            .unwrap_or(false)
            || self
                .dev_dependencies
                .as_ref()
                .map(|deps| deps.contains_key(name))
                .unwrap_or(false)
    }
}

/// Detect the Node.js framework used in a project
///
/// This function reads package.json and analyzes dependencies to determine
/// which framework is being used. The detection order matters - more specific
/// frameworks are checked first.
pub fn detect_node_framework(project_path: &Path) -> NodeFramework {
    let package_json_path = project_path.join("package.json");

    if !package_json_path.exists() {
        debug!("No package.json found at {:?}", package_json_path);
        return NodeFramework::Generic;
    }

    let package_json_content = match fs::read_to_string(&package_json_path) {
        Ok(content) => content,
        Err(e) => {
            warn!("Failed to read package.json: {}", e);
            return NodeFramework::Generic;
        }
    };

    let package_json: PackageJson = match serde_json::from_str(&package_json_content) {
        Ok(pkg) => pkg,
        Err(e) => {
            warn!("Failed to parse package.json: {}", e);
            return NodeFramework::Generic;
        }
    };

    // Detection order matters - check most specific frameworks first
    // Priority: Astro > Next.js > NestJS > Nuxt > Remix > Vite > Vue > Express

    if package_json.has_dependency("astro") {
        debug!("Detected Astro framework");
        return NodeFramework::Astro;
    }

    if package_json.has_dependency("next") {
        debug!("Detected Next.js framework");
        return NodeFramework::NextJs;
    }

    if package_json.has_dependency("@nestjs/core") {
        debug!("Detected NestJS framework");
        return NodeFramework::NestJs;
    }

    if package_json.has_dependency("nuxt") {
        debug!("Detected Nuxt framework");
        return NodeFramework::Nuxt;
    }

    if package_json.has_dependency("@remix-run/react") {
        debug!("Detected Remix framework");
        return NodeFramework::Remix;
    }

    if package_json.has_dependency("vite") {
        debug!("Detected Vite framework");
        return NodeFramework::Vite;
    }

    if package_json.has_dependency("vue") {
        debug!("Detected Vue framework");
        return NodeFramework::Vue;
    }

    if package_json.has_dependency("express") {
        debug!("Detected Express framework");
        return NodeFramework::Express;
    }

    debug!("No specific framework detected, using generic Node.js");
    NodeFramework::Generic
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn create_package_json(temp_dir: &TempDir, dependencies: &[(&str, &str)]) {
        let mut deps = std::collections::HashMap::new();
        for (name, version) in dependencies {
            deps.insert(name.to_string(), version.to_string());
        }

        let package_json = serde_json::json!({
            "name": "test-app",
            "version": "1.0.0",
            "dependencies": deps
        });

        fs::write(
            temp_dir.path().join("package.json"),
            serde_json::to_string_pretty(&package_json).unwrap(),
        )
        .unwrap();
    }

    #[test]
    fn test_detect_astro() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("astro", "^4.0.0"), ("react", "^18.0.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Astro);
        assert!(framework.nixpacks_config().is_some());
        assert!(framework
            .nixpacks_config()
            .unwrap()
            .contains("--host 0.0.0.0"));
    }

    #[test]
    fn test_detect_nextjs() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("next", "^14.0.0"), ("react", "^18.0.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::NextJs);
    }

    #[test]
    fn test_detect_vite() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("vite", "^5.0.0"), ("react", "^18.0.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Vite);
        assert!(framework.nixpacks_config().is_some());
    }

    #[test]
    fn test_detect_nestjs() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(
            &temp_dir,
            &[
                ("@nestjs/core", "^10.0.0"),
                ("@nestjs/common", "^10.0.0"),
            ],
        );

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::NestJs);
    }

    #[test]
    fn test_detect_nuxt() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("nuxt", "^3.0.0"), ("vue", "^3.0.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Nuxt);
    }

    #[test]
    fn test_detect_express() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("express", "^4.18.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Express);
    }

    #[test]
    fn test_generic_node() {
        let temp_dir = TempDir::new().unwrap();
        create_package_json(&temp_dir, &[("lodash", "^4.17.0")]);

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Generic);
        assert!(framework.nixpacks_config().is_none());
    }

    #[test]
    fn test_no_package_json() {
        let temp_dir = TempDir::new().unwrap();

        let framework = detect_node_framework(temp_dir.path());
        assert_eq!(framework, NodeFramework::Generic);
    }

    #[test]
    fn test_framework_names() {
        assert_eq!(NodeFramework::Astro.name(), "Astro");
        assert_eq!(NodeFramework::NextJs.name(), "Next.js");
        assert_eq!(NodeFramework::NestJs.name(), "NestJS");
    }
}
