//! Vulnerability notification handler
//!
//! Handles sending email notifications for high-severity vulnerabilities found during scans

use crate::services::NotificationService;
use crate::types::{Notification, NotificationPriority, NotificationType};
use anyhow::Result;
use sea_orm::{DatabaseConnection, EntityTrait};
use std::collections::HashMap;
use std::sync::Arc;
use temps_core::jobs::VulnerabilityScanCompletedJob;
use temps_entities::{projects, vulnerability_scans};
use tracing::{error, info};

pub struct VulnerabilityNotificationHandler {
    db: Arc<DatabaseConnection>,
    notification_service: Arc<NotificationService>,
    base_url: String,
}

impl VulnerabilityNotificationHandler {
    pub fn new(
        db: Arc<DatabaseConnection>,
        notification_service: Arc<NotificationService>,
        base_url: String,
    ) -> Self {
        Self {
            db,
            notification_service,
            base_url,
        }
    }

    /// Handle vulnerability scan completed job
    ///
    /// Sends email notification to admins if high-severity vulnerabilities are found
    pub async fn handle_scan_completed(&self, job: VulnerabilityScanCompletedJob) -> Result<()> {
        // Only send notification for high or critical vulnerabilities
        if job.high_count == 0 && job.critical_count == 0 {
            info!(
                "Scan {} completed with no high/critical vulnerabilities, skipping notification",
                job.scan_id
            );
            return Ok(());
        }

        info!(
            "Vulnerability scan {} found {} critical and {} high vulnerabilities, sending notification",
            job.scan_id, job.critical_count, job.high_count
        );

        // Get project details
        let project = temps_entities::projects::Entity::find_by_id(job.project_id)
            .one(self.db.as_ref())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to fetch project: {}", e))?
            .ok_or_else(|| anyhow::anyhow!("Project {} not found", job.project_id))?;

        // Get scan details
        let scan = vulnerability_scans::Entity::find_by_id(job.scan_id)
            .one(self.db.as_ref())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to fetch scan: {}", e))?
            .ok_or_else(|| anyhow::anyhow!("Scan {} not found", job.scan_id))?;

        // Build UI link
        let ui_link = format!(
            "{}/projects/{}/vulnerabilities/scans/{}",
            self.base_url.trim_end_matches('/'),
            project.slug,
            job.scan_id
        );

        // Build notification
        let title = format!(
            "âš ï¸ High-Severity Vulnerabilities Detected in {}",
            project.name
        );

        let message = self.build_notification_message(
            &project,
            &scan,
            job.critical_count,
            job.high_count,
            job.total_vulnerabilities,
            &ui_link,
        );

        let mut metadata = HashMap::new();
        metadata.insert("project_id".to_string(), job.project_id.to_string());
        metadata.insert("project_name".to_string(), project.name.clone());
        metadata.insert("scan_id".to_string(), job.scan_id.to_string());
        metadata.insert("critical_count".to_string(), job.critical_count.to_string());
        metadata.insert("high_count".to_string(), job.high_count.to_string());
        metadata.insert(
            "total_count".to_string(),
            job.total_vulnerabilities.to_string(),
        );
        metadata.insert("ui_link".to_string(), ui_link.clone());

        if let Some(env_id) = job.environment_id {
            metadata.insert("environment_id".to_string(), env_id.to_string());
        }
        if let Some(deploy_id) = job.deployment_id {
            metadata.insert("deployment_id".to_string(), deploy_id.to_string());
        }
        if let Some(branch) = &scan.branch {
            metadata.insert("branch".to_string(), branch.clone());
        }
        if let Some(commit) = &scan.commit_hash {
            metadata.insert("commit_hash".to_string(), commit.clone());
        }

        let notification = Notification {
            id: uuid::Uuid::new_v4().to_string(),
            title,
            message,
            notification_type: NotificationType::Alert,
            priority: if job.critical_count > 0 {
                NotificationPriority::Critical
            } else {
                NotificationPriority::High
            },
            severity: None,
            timestamp: chrono::Utc::now(),
            metadata,
            bypass_throttling: false,
        };

        // Send notification
        self.notification_service
            .send_notification(notification)
            .await
            .map_err(|e| {
                error!("Failed to send vulnerability notification: {}", e);
                anyhow::anyhow!("Failed to send vulnerability notification: {}", e)
            })?;

        info!(
            "Successfully sent vulnerability notification for scan {}",
            job.scan_id
        );

        Ok(())
    }

    fn build_notification_message(
        &self,
        project: &projects::Model,
        scan: &vulnerability_scans::Model,
        critical_count: i32,
        high_count: i32,
        total_count: i32,
        ui_link: &str,
    ) -> String {
        let mut message = String::new();

        message.push_str(&format!(
            "A vulnerability scan has detected high-severity security issues in project '{}'.\n\n",
            project.name
        ));

        message.push_str("Vulnerability Summary:\n");
        if critical_count > 0 {
            message.push_str(&format!(
                "  â€¢ CRITICAL: {} vulnerabilities\n",
                critical_count
            ));
        }
        if high_count > 0 {
            message.push_str(&format!("  â€¢ HIGH: {} vulnerabilities\n", high_count));
        }
        message.push_str(&format!("  â€¢ Total: {} vulnerabilities\n\n", total_count));

        message.push_str("Scan Details:\n");
        message.push_str(&format!("  â€¢ Scanner: {}\n", scan.scanner_type));
        if let Some(version) = &scan.scanner_version {
            message.push_str(&format!("  â€¢ Scanner Version: {}\n", version));
        }
        if let Some(branch) = &scan.branch {
            message.push_str(&format!("  â€¢ Branch: {}\n", branch));
        }
        if let Some(commit) = &scan.commit_hash {
            message.push_str(&format!("  â€¢ Commit: {}\n", commit));
        }

        message.push_str(&format!(
            "\nView detailed vulnerability report and take action:\n{}",
            ui_link
        ));

        message
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sea_orm::{ActiveModelTrait, Set};
    use temps_core::EncryptionService;
    use temps_database::test_utils::TestDatabase;

    /// Check if Docker is available by running `docker info`
    async fn is_docker_available() -> bool {
        tokio::process::Command::new("docker")
            .arg("info")
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .await
            .map(|s| s.success())
            .unwrap_or(false)
    }

    async fn setup_test_handler() -> (VulnerabilityNotificationHandler, TestDatabase) {
        let test_db = TestDatabase::with_migrations()
            .await
            .expect("Failed to create test database");

        let encryption_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
        let encryption_service = Arc::new(
            EncryptionService::new(encryption_key).expect("Failed to create encryption service"),
        );

        let notification_service = Arc::new(NotificationService::new(
            test_db.connection_arc(),
            encryption_service,
        ));

        let handler = VulnerabilityNotificationHandler::new(
            test_db.connection_arc(),
            notification_service,
            "https://temps.example.com".to_string(),
        );

        (handler, test_db)
    }

    #[tokio::test]
    async fn test_handle_scan_with_no_high_vulnerabilities() {
        let (handler, test_db) = setup_test_handler().await;

        // Create test project
        let project = temps_entities::projects::ActiveModel {
            name: Set("test-project".to_string()),
            slug: Set("test-project".to_string()),
            repo_name: Set("test-repo".to_string()),
            repo_owner: Set("test-owner".to_string()),
            directory: Set("/".to_string()),
            main_branch: Set("main".to_string()),
            preset: Set(temps_entities::preset::Preset::Astro),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let project = project.insert(test_db.connection()).await.unwrap();

        // Create scan with no high vulnerabilities
        let scan = vulnerability_scans::ActiveModel {
            project_id: Set(project.id),
            environment_id: Set(None),
            deployment_id: Set(None),
            branch: Set(Some("main".to_string())),
            commit_hash: Set(Some("abc123".to_string())),
            scanner_type: Set("trivy".to_string()),
            scanner_version: Set(Some("0.50.0".to_string())),
            status: Set("completed".to_string()),
            total_count: Set(5),
            critical_count: Set(0),
            high_count: Set(0),
            medium_count: Set(5),
            low_count: Set(0),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(chrono::Utc::now()),
            completed_at: Set(Some(chrono::Utc::now())),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let scan = scan.insert(test_db.connection()).await.unwrap();

        let job = VulnerabilityScanCompletedJob {
            scan_id: scan.id,
            project_id: project.id,
            environment_id: None,
            deployment_id: None,
            total_vulnerabilities: 5,
            critical_count: 0,
            high_count: 0,
            medium_count: 5,
            low_count: 0,
            status: "completed".to_string(),
        };

        // Should not send notification (no high/critical vulnerabilities)
        let result = handler.handle_scan_completed(job).await;
        assert!(result.is_ok());

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_handle_scan_with_high_vulnerabilities() {
        let (handler, test_db) = setup_test_handler().await;

        // Create test project
        let project = temps_entities::projects::ActiveModel {
            name: Set("test-project-vuln".to_string()),
            slug: Set("test-project-vuln".to_string()),
            repo_name: Set("test-repo".to_string()),
            repo_owner: Set("test-owner".to_string()),
            directory: Set("/".to_string()),
            main_branch: Set("main".to_string()),
            preset: Set(temps_entities::preset::Preset::Astro),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let project = project.insert(test_db.connection()).await.unwrap();

        // Create scan with high vulnerabilities
        let scan = vulnerability_scans::ActiveModel {
            project_id: Set(project.id),
            environment_id: Set(None),
            deployment_id: Set(None),
            branch: Set(Some("main".to_string())),
            commit_hash: Set(Some("def456".to_string())),
            scanner_type: Set("trivy".to_string()),
            scanner_version: Set(Some("0.50.0".to_string())),
            status: Set("completed".to_string()),
            total_count: Set(15),
            critical_count: Set(2),
            high_count: Set(5),
            medium_count: Set(8),
            low_count: Set(0),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(chrono::Utc::now()),
            completed_at: Set(Some(chrono::Utc::now())),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let scan = scan.insert(test_db.connection()).await.unwrap();

        let job = VulnerabilityScanCompletedJob {
            scan_id: scan.id,
            project_id: project.id,
            environment_id: None,
            deployment_id: None,
            total_vulnerabilities: 15,
            critical_count: 2,
            high_count: 5,
            medium_count: 8,
            low_count: 0,
            status: "completed".to_string(),
        };

        // Should send notification (has high/critical vulnerabilities)
        let result = handler.handle_scan_completed(job).await;
        assert!(result.is_ok());

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_build_notification_message() {
        let (handler, test_db) = setup_test_handler().await;

        let now = chrono::Utc::now();

        let project = temps_entities::projects::Model {
            id: 1,
            name: "My Project".to_string(),
            slug: "my-project".to_string(),
            repo_name: "my-repo".to_string(),
            repo_owner: "owner".to_string(),
            directory: "/".to_string(),
            main_branch: "main".to_string(),
            preset: temps_entities::preset::Preset::Astro,
            preset_config: None,
            deployment_config: None,
            enable_preview_environments: false,
            created_at: now,
            updated_at: now,
            is_deleted: false,
            deleted_at: None,
            last_deployment: None,
            is_public_repo: false,
            git_url: None,
            git_provider_connection_id: None,
            attack_mode: false,
        };

        let scan = vulnerability_scans::Model {
            id: 1,
            project_id: 1,
            environment_id: None,
            deployment_id: None,
            branch: Some("feature-branch".to_string()),
            commit_hash: Some("abc123def".to_string()),
            scanner_type: "trivy".to_string(),
            scanner_version: Some("0.50.0".to_string()),
            status: "completed".to_string(),
            total_count: 10,
            critical_count: 2,
            high_count: 3,
            medium_count: 5,
            low_count: 0,
            unknown_count: 0,
            error_message: None,
            started_at: chrono::Utc::now(),
            completed_at: Some(chrono::Utc::now()),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        };

        let message = handler.build_notification_message(
            &project,
            &scan,
            2,
            3,
            10,
            "https://temps.example.com/projects/my-project/vulnerabilities/scans/1",
        );

        assert!(message.contains("My Project"));
        assert!(message.contains("CRITICAL: 2 vulnerabilities"));
        assert!(message.contains("HIGH: 3 vulnerabilities"));
        assert!(message.contains("Total: 10 vulnerabilities"));
        assert!(message.contains("Scanner: trivy"));
        assert!(message.contains("Scanner Version: 0.50.0"));
        assert!(message.contains("Branch: feature-branch"));
        assert!(message.contains("Commit: abc123def"));
        assert!(message
            .contains("https://temps.example.com/projects/my-project/vulnerabilities/scans/1"));

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_vulnerability_notification_with_mailpit() {
        use testcontainers::{core::ContainerPort, runners::AsyncRunner, GenericImage};

        // Skip if Docker is not available
        if !is_docker_available().await {
            println!("âš ï¸  Docker not available, skipping Mailpit email notification test");
            return;
        }

        // Start Mailpit container for email testing
        let mailpit_container = GenericImage::new("axllent/mailpit", "latest")
            .with_exposed_port(ContainerPort::Tcp(1025)) // SMTP port
            .with_exposed_port(ContainerPort::Tcp(8025)) // Web UI port
            .start()
            .await
            .expect("Failed to start Mailpit container");

        let mailpit_smtp_port = mailpit_container
            .get_host_port_ipv4(1025)
            .await
            .expect("Failed to get SMTP port");
        let mailpit_web_port = mailpit_container
            .get_host_port_ipv4(8025)
            .await
            .expect("Failed to get web port");

        // Wait for Mailpit to be ready
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

        println!(
            "Mailpit started - SMTP: {}, Web UI: http://localhost:{}",
            mailpit_smtp_port, mailpit_web_port
        );

        // Create test database
        let test_db = TestDatabase::with_migrations()
            .await
            .expect("Failed to create test database");

        // Create encryption service
        let encryption_service = Arc::new(
            EncryptionService::new(
                "0000000000000000000000000000000000000000000000000000000000000000",
            )
            .expect("Failed to create encryption service"),
        );

        // Create notification service
        let notification_service = Arc::new(crate::services::NotificationService::new(
            test_db.connection_arc(),
            encryption_service.clone(),
        ));

        // Create handler
        let handler = VulnerabilityNotificationHandler::new(
            test_db.connection_arc(),
            notification_service.clone(),
            "https://temps.example.com".to_string(),
        );

        // Create SMTP provider in database
        let smtp_config = serde_json::json!({
            "host": "127.0.0.1",
            "port": mailpit_smtp_port,
            "username": "",
            "password": "",
            "from_email": "noreply@temps.local",
            "from_name": "Temps Security Scanner",
            "use_tls": false,
            "use_starttls": false
        });

        let smtp_provider = temps_entities::notification_providers::ActiveModel {
            provider_type: Set("smtp".to_string()),
            name: Set("Mailpit Test SMTP".to_string()),
            config: Set(smtp_config.to_string()),
            enabled: Set(true),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let smtp_provider = smtp_provider
            .insert(test_db.connection())
            .await
            .expect("Failed to create SMTP provider");

        // Create notification preferences for admin email
        let preferences_json = serde_json::json!({
            "providers": [{
                "provider_id": smtp_provider.id,
                "notification_type": "alert",
                "enabled": true,
                "recipients": ["admin@temps.local"]
            }]
        });

        let preferences = temps_entities::notification_preferences::ActiveModel {
            preferences: Set(preferences_json.to_string()),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        preferences
            .insert(test_db.connection())
            .await
            .expect("Failed to create preferences");

        // Create test project
        let project = temps_entities::projects::ActiveModel {
            name: Set("Critical Vulnerability Project".to_string()),
            slug: Set("critical-vuln-project".to_string()),
            repo_name: Set("critical-repo".to_string()),
            repo_owner: Set("security-team".to_string()),
            directory: Set("/".to_string()),
            main_branch: Set("main".to_string()),
            preset: Set(temps_entities::preset::Preset::Astro),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let project = project
            .insert(test_db.connection())
            .await
            .expect("Failed to create project");

        // Create scan with critical and high vulnerabilities
        let scan = vulnerability_scans::ActiveModel {
            project_id: Set(project.id),
            environment_id: Set(None),
            deployment_id: Set(None),
            branch: Set(Some("production".to_string())),
            commit_hash: Set(Some("abc123def456".to_string())),
            scanner_type: Set("trivy".to_string()),
            scanner_version: Set(Some("0.58.1".to_string())),
            status: Set("completed".to_string()),
            total_count: Set(25),
            critical_count: Set(5),
            high_count: Set(10),
            medium_count: Set(8),
            low_count: Set(2),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(chrono::Utc::now()),
            completed_at: Set(Some(chrono::Utc::now())),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let scan = scan
            .insert(test_db.connection())
            .await
            .expect("Failed to create scan");

        // Create job
        let job = VulnerabilityScanCompletedJob {
            scan_id: scan.id,
            project_id: project.id,
            environment_id: None,
            deployment_id: None,
            total_vulnerabilities: 25,
            critical_count: 5,
            high_count: 10,
            medium_count: 8,
            low_count: 2,
            status: "completed".to_string(),
        };

        // Send notification
        let result = handler.handle_scan_completed(job).await;
        assert!(
            result.is_ok(),
            "Failed to send notification: {:?}",
            result.err()
        );

        // Wait for email to be sent
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

        // Verify email was sent by checking Mailpit API
        let client = reqwest::Client::new();
        let messages_url = format!("http://localhost:{}/api/v1/messages", mailpit_web_port);
        let response = client
            .get(&messages_url)
            .send()
            .await
            .expect("Failed to fetch messages from Mailpit");

        assert!(
            response.status().is_success(),
            "Failed to fetch Mailpit messages"
        );

        let messages: serde_json::Value = response
            .json()
            .await
            .expect("Failed to parse Mailpit response");

        // Check that at least one email was sent
        let total_messages = messages["total"]
            .as_u64()
            .expect("Failed to get message count");
        assert!(
            total_messages > 0,
            "No emails were sent to Mailpit (expected at least 1)"
        );

        // Get the first message details
        let message_id = messages["messages"][0]["ID"]
            .as_str()
            .expect("Failed to get message ID");
        let message_url = format!(
            "http://localhost:{}/api/v1/message/{}",
            mailpit_web_port, message_id
        );
        let message_response = client
            .get(&message_url)
            .send()
            .await
            .expect("Failed to fetch message details");

        let message: serde_json::Value = message_response
            .json()
            .await
            .expect("Failed to parse message");

        // Verify email content
        let subject = message["Subject"].as_str().expect("Failed to get subject");
        let text_body = message["Text"].as_str().expect("Failed to get text body");

        println!("Email Subject: {}", subject);
        println!("Email Body:\n{}", text_body);

        // Assertions on email content
        assert!(
            subject.contains("High-Severity Vulnerabilities"),
            "Subject should mention high-severity vulnerabilities"
        );
        assert!(
            subject.contains("Critical Vulnerability Project"),
            "Subject should contain project name"
        );

        assert!(
            text_body.contains("CRITICAL: 5 vulnerabilities"),
            "Body should mention critical vulnerabilities"
        );
        assert!(
            text_body.contains("HIGH: 10 vulnerabilities"),
            "Body should mention high vulnerabilities"
        );
        assert!(
            text_body.contains("Total: 25 vulnerabilities"),
            "Body should mention total vulnerabilities"
        );
        assert!(
            text_body.contains("Scanner: trivy"),
            "Body should mention scanner type"
        );
        assert!(
            text_body.contains("Scanner Version: 0.58.1"),
            "Body should mention scanner version"
        );
        assert!(
            text_body.contains("Branch: production"),
            "Body should mention branch"
        );
        assert!(
            text_body.contains("Commit: abc123def456"),
            "Body should mention commit hash"
        );
        assert!(
            text_body.contains(
                "https://temps.example.com/projects/critical-vuln-project/vulnerabilities/scans/"
            ),
            "Body should contain link to vulnerability report"
        );

        println!("âœ… Vulnerability notification email verified successfully!");
        println!(
            "ðŸ“§ View email in Mailpit UI: http://localhost:{}",
            mailpit_web_port
        );

        // Cleanup
        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }
}
