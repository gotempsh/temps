//! Vulnerability notification handler
//!
//! Handles sending email notifications for high-severity vulnerabilities found during scans

use crate::services::NotificationService;
use crate::types::{Notification, NotificationPriority, NotificationType};
use anyhow::Result;
use sea_orm::{DatabaseConnection, EntityTrait};
use std::collections::HashMap;
use std::sync::Arc;
use temps_core::jobs::VulnerabilityScanCompletedJob;
use temps_entities::{projects, vulnerability_scans};
use tracing::{error, info};

pub struct VulnerabilityNotificationHandler {
    db: Arc<DatabaseConnection>,
    notification_service: Arc<NotificationService>,
    base_url: String,
}

impl VulnerabilityNotificationHandler {
    pub fn new(
        db: Arc<DatabaseConnection>,
        notification_service: Arc<NotificationService>,
        base_url: String,
    ) -> Self {
        Self {
            db,
            notification_service,
            base_url,
        }
    }

    /// Handle vulnerability scan completed job
    ///
    /// Sends email notification to admins if high-severity vulnerabilities are found
    pub async fn handle_scan_completed(&self, job: VulnerabilityScanCompletedJob) -> Result<()> {
        // Only send notification for high or critical vulnerabilities
        if job.high_count == 0 && job.critical_count == 0 {
            info!(
                "Scan {} completed with no high/critical vulnerabilities, skipping notification",
                job.scan_id
            );
            return Ok(());
        }

        info!(
            "Vulnerability scan {} found {} critical and {} high vulnerabilities, sending notification",
            job.scan_id, job.critical_count, job.high_count
        );

        // Get project details
        let project = temps_entities::projects::Entity::find_by_id(job.project_id)
            .one(self.db.as_ref())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to fetch project: {}", e))?
            .ok_or_else(|| anyhow::anyhow!("Project {} not found", job.project_id))?;

        // Get scan details
        let scan = vulnerability_scans::Entity::find_by_id(job.scan_id)
            .one(self.db.as_ref())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to fetch scan: {}", e))?
            .ok_or_else(|| anyhow::anyhow!("Scan {} not found", job.scan_id))?;

        // Build UI link
        let ui_link = format!(
            "{}/projects/{}/vulnerabilities/scans/{}",
            self.base_url.trim_end_matches('/'),
            project.slug,
            job.scan_id
        );

        // Build notification
        let title = format!(
            "⚠️ High-Severity Vulnerabilities Detected in {}",
            project.name
        );

        let message = self.build_notification_message(
            &project,
            &scan,
            job.critical_count,
            job.high_count,
            job.total_vulnerabilities,
            &ui_link,
        );

        let mut metadata = HashMap::new();
        metadata.insert("project_id".to_string(), job.project_id.to_string());
        metadata.insert("project_name".to_string(), project.name.clone());
        metadata.insert("scan_id".to_string(), job.scan_id.to_string());
        metadata.insert("critical_count".to_string(), job.critical_count.to_string());
        metadata.insert("high_count".to_string(), job.high_count.to_string());
        metadata.insert(
            "total_count".to_string(),
            job.total_vulnerabilities.to_string(),
        );
        metadata.insert("ui_link".to_string(), ui_link.clone());

        if let Some(env_id) = job.environment_id {
            metadata.insert("environment_id".to_string(), env_id.to_string());
        }
        if let Some(deploy_id) = job.deployment_id {
            metadata.insert("deployment_id".to_string(), deploy_id.to_string());
        }
        if let Some(branch) = &scan.branch {
            metadata.insert("branch".to_string(), branch.clone());
        }
        if let Some(commit) = &scan.commit_hash {
            metadata.insert("commit_hash".to_string(), commit.clone());
        }

        let notification = Notification {
            id: uuid::Uuid::new_v4().to_string(),
            title,
            message,
            notification_type: NotificationType::Alert,
            priority: if job.critical_count > 0 {
                NotificationPriority::Critical
            } else {
                NotificationPriority::High
            },
            severity: None,
            timestamp: chrono::Utc::now(),
            metadata,
            bypass_throttling: false,
        };

        // Send notification
        self.notification_service
            .send_notification(notification)
            .await
            .map_err(|e| {
                error!("Failed to send vulnerability notification: {}", e);
                anyhow::anyhow!("Failed to send vulnerability notification: {}", e)
            })?;

        info!(
            "Successfully sent vulnerability notification for scan {}",
            job.scan_id
        );

        Ok(())
    }

    fn build_notification_message(
        &self,
        project: &projects::Model,
        scan: &vulnerability_scans::Model,
        critical_count: i32,
        high_count: i32,
        total_count: i32,
        ui_link: &str,
    ) -> String {
        let mut message = String::new();

        message.push_str(&format!(
            "A vulnerability scan has detected high-severity security issues in project '{}'.\n\n",
            project.name
        ));

        message.push_str("Vulnerability Summary:\n");
        if critical_count > 0 {
            message.push_str(&format!(
                "  • CRITICAL: {} vulnerabilities\n",
                critical_count
            ));
        }
        if high_count > 0 {
            message.push_str(&format!("  • HIGH: {} vulnerabilities\n", high_count));
        }
        message.push_str(&format!("  • Total: {} vulnerabilities\n\n", total_count));

        message.push_str("Scan Details:\n");
        message.push_str(&format!("  • Scanner: {}\n", scan.scanner_type));
        if let Some(version) = &scan.scanner_version {
            message.push_str(&format!("  • Scanner Version: {}\n", version));
        }
        if let Some(branch) = &scan.branch {
            message.push_str(&format!("  • Branch: {}\n", branch));
        }
        if let Some(commit) = &scan.commit_hash {
            message.push_str(&format!("  • Commit: {}\n", commit));
        }

        message.push_str(&format!(
            "\nView detailed vulnerability report and take action:\n{}",
            ui_link
        ));

        message
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sea_orm::{ActiveModelTrait, Set};
    use temps_core::EncryptionService;
    use temps_database::test_utils::TestDatabase;

    async fn setup_test_handler() -> (VulnerabilityNotificationHandler, TestDatabase) {
        let test_db = TestDatabase::with_migrations()
            .await
            .expect("Failed to create test database");

        let encryption_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
        let encryption_service = Arc::new(
            EncryptionService::new(encryption_key).expect("Failed to create encryption service"),
        );

        let notification_service = Arc::new(NotificationService::new(
            test_db.connection_arc(),
            encryption_service,
        ));

        let handler = VulnerabilityNotificationHandler::new(
            test_db.connection_arc(),
            notification_service,
            "https://temps.example.com".to_string(),
        );

        (handler, test_db)
    }

    #[tokio::test]
    async fn test_handle_scan_with_no_high_vulnerabilities() {
        let (handler, test_db) = setup_test_handler().await;

        // Create test project
        let project = temps_entities::projects::ActiveModel {
            name: Set("test-project".to_string()),
            slug: Set("test-project".to_string()),
            repo_name: Set("test-repo".to_string()),
            repo_owner: Set("test-owner".to_string()),
            directory: Set("/".to_string()),
            main_branch: Set("main".to_string()),
            preset: Set(temps_entities::preset::Preset::Astro),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let project = project.insert(test_db.connection()).await.unwrap();

        // Create scan with no high vulnerabilities
        let scan = vulnerability_scans::ActiveModel {
            project_id: Set(project.id),
            environment_id: Set(None),
            deployment_id: Set(None),
            branch: Set(Some("main".to_string())),
            commit_hash: Set(Some("abc123".to_string())),
            scanner_type: Set("trivy".to_string()),
            scanner_version: Set(Some("0.50.0".to_string())),
            status: Set("completed".to_string()),
            total_count: Set(5),
            critical_count: Set(0),
            high_count: Set(0),
            medium_count: Set(5),
            low_count: Set(0),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(chrono::Utc::now()),
            completed_at: Set(Some(chrono::Utc::now())),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let scan = scan.insert(test_db.connection()).await.unwrap();

        let job = VulnerabilityScanCompletedJob {
            scan_id: scan.id,
            project_id: project.id,
            environment_id: None,
            deployment_id: None,
            total_vulnerabilities: 5,
            critical_count: 0,
            high_count: 0,
            medium_count: 5,
            low_count: 0,
            status: "completed".to_string(),
        };

        // Should not send notification (no high/critical vulnerabilities)
        let result = handler.handle_scan_completed(job).await;
        assert!(result.is_ok());

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_handle_scan_with_high_vulnerabilities() {
        let (handler, test_db) = setup_test_handler().await;

        // Create test project
        let project = temps_entities::projects::ActiveModel {
            name: Set("test-project-vuln".to_string()),
            slug: Set("test-project-vuln".to_string()),
            repo_name: Set("test-repo".to_string()),
            repo_owner: Set("test-owner".to_string()),
            directory: Set("/".to_string()),
            main_branch: Set("main".to_string()),
            preset: Set(temps_entities::preset::Preset::Astro),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let project = project.insert(test_db.connection()).await.unwrap();

        // Create scan with high vulnerabilities
        let scan = vulnerability_scans::ActiveModel {
            project_id: Set(project.id),
            environment_id: Set(None),
            deployment_id: Set(None),
            branch: Set(Some("main".to_string())),
            commit_hash: Set(Some("def456".to_string())),
            scanner_type: Set("trivy".to_string()),
            scanner_version: Set(Some("0.50.0".to_string())),
            status: Set("completed".to_string()),
            total_count: Set(15),
            critical_count: Set(2),
            high_count: Set(5),
            medium_count: Set(8),
            low_count: Set(0),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(chrono::Utc::now()),
            completed_at: Set(Some(chrono::Utc::now())),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        };
        let scan = scan.insert(test_db.connection()).await.unwrap();

        let job = VulnerabilityScanCompletedJob {
            scan_id: scan.id,
            project_id: project.id,
            environment_id: None,
            deployment_id: None,
            total_vulnerabilities: 15,
            critical_count: 2,
            high_count: 5,
            medium_count: 8,
            low_count: 0,
            status: "completed".to_string(),
        };

        // Should send notification (has high/critical vulnerabilities)
        let result = handler.handle_scan_completed(job).await;
        assert!(result.is_ok());

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }

    #[tokio::test]
    async fn test_build_notification_message() {
        let (handler, test_db) = setup_test_handler().await;

        let now = chrono::Utc::now();

        let project = temps_entities::projects::Model {
            id: 1,
            name: "My Project".to_string(),
            slug: "my-project".to_string(),
            repo_name: "my-repo".to_string(),
            repo_owner: "owner".to_string(),
            directory: "/".to_string(),
            main_branch: "main".to_string(),
            preset: temps_entities::preset::Preset::Astro,
            preset_config: None,
            deployment_config: None,
            enable_preview_environments: false,
            created_at: now,
            updated_at: now,
            is_deleted: false,
            deleted_at: None,
            last_deployment: None,
            is_public_repo: false,
            git_url: None,
            git_provider_connection_id: None,
            attack_mode: false,
        };

        let scan = vulnerability_scans::Model {
            id: 1,
            project_id: 1,
            environment_id: None,
            deployment_id: None,
            branch: Some("feature-branch".to_string()),
            commit_hash: Some("abc123def".to_string()),
            scanner_type: "trivy".to_string(),
            scanner_version: Some("0.50.0".to_string()),
            status: "completed".to_string(),
            total_count: 10,
            critical_count: 2,
            high_count: 3,
            medium_count: 5,
            low_count: 0,
            unknown_count: 0,
            error_message: None,
            started_at: chrono::Utc::now(),
            completed_at: Some(chrono::Utc::now()),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        };

        let message = handler.build_notification_message(
            &project,
            &scan,
            2,
            3,
            10,
            "https://temps.example.com/projects/my-project/vulnerabilities/scans/1",
        );

        assert!(message.contains("My Project"));
        assert!(message.contains("CRITICAL: 2 vulnerabilities"));
        assert!(message.contains("HIGH: 3 vulnerabilities"));
        assert!(message.contains("Total: 10 vulnerabilities"));
        assert!(message.contains("Scanner: trivy"));
        assert!(message.contains("Scanner Version: 0.50.0"));
        assert!(message.contains("Branch: feature-branch"));
        assert!(message.contains("Commit: abc123def"));
        assert!(message
            .contains("https://temps.example.com/projects/my-project/vulnerabilities/scans/1"));

        test_db.cleanup_all_tables().await.expect("Cleanup failed");
    }
}
