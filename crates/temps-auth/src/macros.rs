// Note: This will be a procedural macro crate, but for now we'll create
// a simpler function-based approach that can be used similarly

use crate::context::AuthContext;
use crate::permissions::Permission;
use axum::{
    extract::FromRequestParts,
    http::{request::Parts, StatusCode},
};
use temps_core::problemdetails::{self, Problem};

// Helper function for extracting auth context from request parts
pub async fn extract_auth_context(parts: &Parts) -> Result<AuthContext, Problem> {
    // This will be implemented with the middleware
    // For now, return an error to indicate auth is required
    parts
        .extensions
        .get::<AuthContext>()
        .cloned()
        .ok_or_else(|| {
            problemdetails::new(StatusCode::UNAUTHORIZED)
                .with_title("Authentication Required")
                .with_detail("You must be authenticated to access this resource")
        })
}

// Wrapper function to check single permission
pub fn check_permission(
    auth_context: &AuthContext,
    permission: &Permission,
) -> Result<(), Problem> {
    if !auth_context.has_permission(permission) {
        return Err(problemdetails::new(StatusCode::FORBIDDEN)
            .with_title("Insufficient Permissions")
            .with_detail(format!(
                "Required permission: {}. Your role: {}",
                permission, auth_context.effective_role
            ))
            .with_value("required_permission", permission.to_string())
            .with_value("user_role", auth_context.effective_role.to_string()));
    }
    Ok(())
}

// Wrapper function to check multiple permissions (AND logic)
pub fn check_permissions(
    auth_context: &AuthContext,
    permissions: &[Permission],
) -> Result<(), Problem> {
    for permission in permissions {
        if !auth_context.has_permission(permission) {
            return Err(problemdetails::new(StatusCode::FORBIDDEN)
                .with_title("Insufficient Permissions")
                .with_detail(format!(
                    "Required permission: {}. Your role: {}",
                    permission, auth_context.effective_role
                ))
                .with_value("required_permission", permission.to_string())
                .with_value("user_role", auth_context.effective_role.to_string()));
        }
    }
    Ok(())
}

#[derive(Clone)]
// Custom extractor for AuthContext that provides better error messages
pub struct RequireAuth(pub AuthContext);

impl<S> FromRequestParts<S> for RequireAuth
where
    S: Send + Sync,
{
    type Rejection = Problem;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        let auth_context = parts
            .extensions
            .get::<AuthContext>()
            .cloned()
            .ok_or_else(|| {
                problemdetails::new(StatusCode::UNAUTHORIZED)
                    .with_title("Authentication Required")
                    .with_detail("You must be authenticated to access this resource")
            })?;
        Ok(RequireAuth(auth_context))
    }
}

// Macro-like function for requiring specific permission
pub struct RequirePermission<const P: u8>(pub AuthContext);

// We'll use a trait-based approach for now since const generics with enums are tricky
pub trait PermissionCheck {
    const REQUIRED_PERMISSION: Permission;

    fn check_permission(auth: &AuthContext) -> Result<(), Problem> {
        check_permission(auth, &Self::REQUIRED_PERMISSION)
    }
}

// Example usage traits (these would be generated by a macro in the future)
pub struct ProjectsReadPermission;
impl PermissionCheck for ProjectsReadPermission {
    const REQUIRED_PERMISSION: Permission = Permission::ProjectsRead;
}

pub struct ProjectsWritePermission;
impl PermissionCheck for ProjectsWritePermission {
    const REQUIRED_PERMISSION: Permission = Permission::ProjectsWrite;
}

pub struct DeploymentsReadPermission;
impl PermissionCheck for DeploymentsReadPermission {
    const REQUIRED_PERMISSION: Permission = Permission::DeploymentsRead;
}

pub struct ApiKeysReadPermission;
impl PermissionCheck for ApiKeysReadPermission {
    const REQUIRED_PERMISSION: Permission = Permission::ApiKeysRead;
}

pub struct ApiKeysWritePermission;
impl PermissionCheck for ApiKeysWritePermission {
    const REQUIRED_PERMISSION: Permission = Permission::ApiKeysWrite;
}

pub struct ApiKeysCreatePermission;
impl PermissionCheck for ApiKeysCreatePermission {
    const REQUIRED_PERMISSION: Permission = Permission::ApiKeysCreate;
}

pub struct ApiKeysDeletePermission;
impl PermissionCheck for ApiKeysDeletePermission {
    const REQUIRED_PERMISSION: Permission = Permission::ApiKeysDelete;
}
