use std::path::PathBuf;
use temps_vulnerability_scanner::{Severity, TrivyScanner, VulnerabilityScanner};

fn get_fixture_path(fixture_name: &str) -> PathBuf {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.push("tests");
    path.push("fixtures");
    path.push(fixture_name);
    path
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_trivy_scanner_creation() {
    let scanner = TrivyScanner::new();
    assert!(scanner.is_ok());

    let scanner = scanner.unwrap();
    assert_eq!(scanner.name(), "trivy");
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_trivy_scanner_version() {
    let scanner = TrivyScanner::new().unwrap();

    let version = scanner.version().await;
    assert!(version.is_ok());

    let version = version.unwrap();
    assert!(version.is_some());

    println!("Trivy version: {}", version.unwrap());
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_scan_vulnerable_node_project() {
    // Check if Docker is available
    if !bollard::Docker::connect_with_local_defaults()
        .map(|_| true)
        .unwrap_or(false)
    {
        println!("Docker not available, skipping test");
        return;
    }

    let scanner = TrivyScanner::new().unwrap();
    let fixture_path = get_fixture_path("vulnerable-node-project");

    println!("Scanning fixture at: {}", fixture_path.display());

    let result = scanner.scan_path(&fixture_path).await;

    match result {
        Ok(scan_result) => {
            println!("Scan completed successfully!");
            println!(
                "Scanner: {} (version: {:?})",
                scan_result.scanner_type, scan_result.scanner_version
            );
            println!("Total vulnerabilities: {}", scan_result.total_count);
            println!("  Critical: {}", scan_result.critical_count);
            println!("  High: {}", scan_result.high_count);
            println!("  Medium: {}", scan_result.medium_count);
            println!("  Low: {}", scan_result.low_count);
            println!("  Unknown: {}", scan_result.unknown_count);

            // Show first 5 vulnerabilities as examples
            for (i, vuln) in scan_result.vulnerabilities.iter().take(5).enumerate() {
                println!("\nVulnerability {}:", i + 1);
                println!("  ID: {}", vuln.vulnerability_id);
                println!(
                    "  Package: {} ({})",
                    vuln.package_name, vuln.installed_version
                );
                println!("  Severity: {:?}", vuln.severity);
                println!("  Title: {}", vuln.title);
                if let Some(fixed) = &vuln.fixed_version {
                    println!("  Fixed in: {}", fixed);
                }
                if let Some(score) = vuln.cvss_score {
                    println!("  CVSS Score: {}", score);
                }
            }

            // Verify we found some vulnerabilities (these old packages should have known issues)
            assert!(
                scan_result.total_count > 0,
                "Expected to find vulnerabilities in old packages"
            );
        }
        Err(e) => {
            panic!("Scan failed: {}", e);
        }
    }
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_scan_vulnerable_python_project() {
    // Check if Docker is available
    if !bollard::Docker::connect_with_local_defaults()
        .map(|_| true)
        .unwrap_or(false)
    {
        println!("Docker not available, skipping test");
        return;
    }

    let scanner = TrivyScanner::new().unwrap();
    let fixture_path = get_fixture_path("vulnerable-python-project");

    println!("Scanning fixture at: {}", fixture_path.display());

    let result = scanner.scan_path(&fixture_path).await;

    match result {
        Ok(scan_result) => {
            println!("Scan completed successfully!");
            println!(
                "Scanner: {} (version: {:?})",
                scan_result.scanner_type, scan_result.scanner_version
            );
            println!("Total vulnerabilities: {}", scan_result.total_count);
            println!("  Critical: {}", scan_result.critical_count);
            println!("  High: {}", scan_result.high_count);
            println!("  Medium: {}", scan_result.medium_count);
            println!("  Low: {}", scan_result.low_count);

            // Show vulnerabilities by severity
            let critical_vulns: Vec<_> = scan_result
                .vulnerabilities
                .iter()
                .filter(|v| v.severity == Severity::Critical)
                .collect();

            if !critical_vulns.is_empty() {
                println!("\nCritical vulnerabilities:");
                for vuln in critical_vulns.iter().take(3) {
                    println!(
                        "  - {} in {} ({})",
                        vuln.vulnerability_id, vuln.package_name, vuln.installed_version
                    );
                }
            }

            // Verify we found vulnerabilities in these very old packages
            assert!(
                scan_result.total_count > 0,
                "Expected to find vulnerabilities in old Python packages"
            );
        }
        Err(e) => {
            panic!("Scan failed: {}", e);
        }
    }
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_scan_empty_directory() {
    // Check if Docker is available
    if !bollard::Docker::connect_with_local_defaults()
        .map(|_| true)
        .unwrap_or(false)
    {
        println!("Docker not available, skipping test");
        return;
    }

    let scanner = TrivyScanner::new().unwrap();

    // Create a temporary empty directory
    let temp_dir = tempfile::tempdir().unwrap();
    let result = scanner.scan_path(temp_dir.path()).await;

    match result {
        Ok(scan_result) => {
            println!("Empty directory scan completed");
            println!("Total vulnerabilities: {}", scan_result.total_count);
            // Empty directory should have no vulnerabilities
            assert_eq!(scan_result.total_count, 0);
        }
        Err(e) => {
            // Empty directory might cause Trivy to return an error or empty result
            println!("Empty directory scan result: {}", e);
        }
    }
}

#[tokio::test]
#[ignore] // Requires Docker to be running
async fn test_scanner_availability() {
    // Check if Docker is available
    if !bollard::Docker::connect_with_local_defaults()
        .map(|_| true)
        .unwrap_or(false)
    {
        println!("Docker not available, skipping test");
        return;
    }

    let scanner = TrivyScanner::new().unwrap();

    // Before pulling image, might not be available
    let available_before = scanner.is_available().await;
    println!("Scanner available before pull: {}", available_before);

    // Try to get version (which will pull the image if needed)
    let version = scanner.version().await;
    assert!(version.is_ok());

    // After pulling, should be available
    let available_after = scanner.is_available().await;
    println!("Scanner available after pull: {}", available_after);
    assert!(
        available_after,
        "Scanner should be available after pulling image"
    );
}
