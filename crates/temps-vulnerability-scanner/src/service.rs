use crate::scanner::{ScanResult, ScannerError, Severity, VulnerabilityScanner};
use sea_orm::prelude::*;
use sea_orm::{ActiveValue::NotSet, Order, QueryOrder, Set};
use std::path::Path;
use std::sync::Arc;
use temps_entities::{vulnerabilities, vulnerability_scans};
use thiserror::Error;
use tracing::{debug, error, info};

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("Database error: {0}")]
    Database(#[from] sea_orm::DbErr),

    #[error("Scanner error: {0}")]
    Scanner(#[from] ScannerError),

    #[error("Scan not found: {0}")]
    NotFound(String),

    #[error("Invalid scan status: {0}")]
    InvalidStatus(String),

    #[error("Internal error: {0}")]
    Internal(String),
}

/// Service for managing vulnerability scans
pub struct VulnerabilityScanService {
    db: Arc<DatabaseConnection>,
    scanner: Arc<dyn VulnerabilityScanner>,
}

impl VulnerabilityScanService {
    pub fn new(db: Arc<DatabaseConnection>, scanner: Arc<dyn VulnerabilityScanner>) -> Self {
        Self { db, scanner }
    }

    /// Create a new scan record
    pub async fn create_scan(
        &self,
        project_id: i32,
        environment_id: Option<i32>,
        deployment_id: Option<i32>,
        branch: Option<String>,
        commit_hash: Option<String>,
    ) -> Result<vulnerability_scans::Model, ServiceError> {
        let now = chrono::Utc::now();

        let scan = vulnerability_scans::ActiveModel {
            id: NotSet,
            project_id: Set(project_id),
            environment_id: Set(environment_id),
            deployment_id: Set(deployment_id),
            branch: Set(branch),
            commit_hash: Set(commit_hash),
            scanner_type: Set(self.scanner.name().to_string()),
            scanner_version: Set(None),
            status: Set("pending".to_string()),
            total_count: Set(0),
            critical_count: Set(0),
            high_count: Set(0),
            medium_count: Set(0),
            low_count: Set(0),
            unknown_count: Set(0),
            error_message: Set(None),
            started_at: Set(now),
            completed_at: Set(None),
            created_at: Set(now),
            updated_at: Set(now),
        };

        let scan = scan.insert(self.db.as_ref()).await?;

        info!(
            "Created vulnerability scan {} for project {} (environment: {:?}, deployment: {:?})",
            scan.id, project_id, environment_id, deployment_id
        );

        Ok(scan)
    }

    /// Execute a vulnerability scan
    pub async fn execute_scan(
        &self,
        scan_id: i32,
        path: &Path,
    ) -> Result<vulnerability_scans::Model, ServiceError> {
        let scan = vulnerability_scans::Entity::find_by_id(scan_id)
            .one(self.db.as_ref())
            .await?
            .ok_or_else(|| ServiceError::NotFound(format!("Scan {} not found", scan_id)))?;

        if scan.status != "pending" {
            return Err(ServiceError::InvalidStatus(format!(
                "Scan {} is not in pending status (current: {})",
                scan_id, scan.status
            )));
        }

        // Update status to running
        let mut scan_active: vulnerability_scans::ActiveModel = scan.clone().into();
        scan_active.status = Set("running".to_string());
        scan_active.started_at = Set(chrono::Utc::now());
        scan_active.updated_at = Set(chrono::Utc::now());
        let scan = scan_active.update(self.db.as_ref()).await?;

        info!(
            "Starting vulnerability scan {} for path: {}",
            scan_id,
            path.display()
        );

        // Execute the scan
        let result = match self.scanner.scan_path(path).await {
            Ok(result) => result,
            Err(e) => {
                error!("Scan {} failed: {}", scan_id, e);

                // Update scan with error
                let mut scan_active: vulnerability_scans::ActiveModel = scan.into();
                scan_active.status = Set("failed".to_string());
                scan_active.error_message = Set(Some(e.to_string()));
                scan_active.completed_at = Set(Some(chrono::Utc::now()));
                scan_active.updated_at = Set(chrono::Utc::now());
                return Ok(scan_active.update(self.db.as_ref()).await?);
            }
        };

        info!(
            "Scan {} completed: {} vulnerabilities found ({} critical, {} high, {} medium, {} low)",
            scan_id,
            result.total_count,
            result.critical_count,
            result.high_count,
            result.medium_count,
            result.low_count
        );

        // Save vulnerabilities
        self.save_vulnerabilities(scan_id, &result).await?;

        // Update scan record with results
        let mut scan_active: vulnerability_scans::ActiveModel = scan.into();
        scan_active.status = Set("completed".to_string());
        scan_active.scanner_version = Set(result.scanner_version.clone());
        scan_active.total_count = Set(result.total_count as i32);
        scan_active.critical_count = Set(result.critical_count as i32);
        scan_active.high_count = Set(result.high_count as i32);
        scan_active.medium_count = Set(result.medium_count as i32);
        scan_active.low_count = Set(result.low_count as i32);
        scan_active.unknown_count = Set(result.unknown_count as i32);
        scan_active.completed_at = Set(Some(chrono::Utc::now()));
        scan_active.updated_at = Set(chrono::Utc::now());

        let scan = scan_active.update(self.db.as_ref()).await?;

        Ok(scan)
    }

    /// Execute a vulnerability scan on a Docker image
    ///
    /// # Arguments
    /// * `scan_id` - ID of the scan record to update
    /// * `image_name` - Full Docker image name with tag (e.g., "myapp:latest")
    ///
    /// # Returns
    /// Updated scan record with results
    pub async fn execute_image_scan(
        &self,
        scan_id: i32,
        image_name: &str,
    ) -> Result<vulnerability_scans::Model, ServiceError> {
        let scan = vulnerability_scans::Entity::find_by_id(scan_id)
            .one(self.db.as_ref())
            .await?
            .ok_or_else(|| ServiceError::NotFound(format!("Scan {} not found", scan_id)))?;

        if scan.status != "pending" {
            return Err(ServiceError::InvalidStatus(format!(
                "Scan {} is not in pending status (current: {})",
                scan_id, scan.status
            )));
        }

        // Update status to running
        let mut scan_active: vulnerability_scans::ActiveModel = scan.clone().into();
        scan_active.status = Set("running".to_string());
        scan_active.started_at = Set(chrono::Utc::now());
        scan_active.updated_at = Set(chrono::Utc::now());
        let scan = scan_active.update(self.db.as_ref()).await?;

        info!(
            "Starting vulnerability scan {} for Docker image: {}",
            scan_id, image_name
        );

        // Execute the scan
        let result = match self.scanner.scan_image(image_name).await {
            Ok(result) => result,
            Err(e) => {
                error!("Image scan {} failed: {}", scan_id, e);

                // Update scan with error
                let mut scan_active: vulnerability_scans::ActiveModel = scan.into();
                scan_active.status = Set("failed".to_string());
                scan_active.error_message = Set(Some(e.to_string()));
                scan_active.completed_at = Set(Some(chrono::Utc::now()));
                scan_active.updated_at = Set(chrono::Utc::now());
                return Ok(scan_active.update(self.db.as_ref()).await?);
            }
        };

        info!(
            "Image scan {} completed: {} vulnerabilities found ({} critical, {} high, {} medium, {} low)",
            scan_id,
            result.total_count,
            result.critical_count,
            result.high_count,
            result.medium_count,
            result.low_count
        );

        // Save vulnerabilities
        self.save_vulnerabilities(scan_id, &result).await?;

        // Update scan record with results
        let mut scan_active: vulnerability_scans::ActiveModel = scan.into();
        scan_active.status = Set("completed".to_string());
        scan_active.scanner_version = Set(result.scanner_version.clone());
        scan_active.total_count = Set(result.total_count as i32);
        scan_active.critical_count = Set(result.critical_count as i32);
        scan_active.high_count = Set(result.high_count as i32);
        scan_active.medium_count = Set(result.medium_count as i32);
        scan_active.low_count = Set(result.low_count as i32);
        scan_active.unknown_count = Set(result.unknown_count as i32);
        scan_active.completed_at = Set(Some(chrono::Utc::now()));
        scan_active.updated_at = Set(chrono::Utc::now());

        let scan = scan_active.update(self.db.as_ref()).await?;

        Ok(scan)
    }

    /// Save vulnerabilities to database
    async fn save_vulnerabilities(
        &self,
        scan_id: i32,
        result: &ScanResult,
    ) -> Result<(), ServiceError> {
        if result.vulnerabilities.is_empty() {
            debug!("No vulnerabilities to save for scan {}", scan_id);
            return Ok(());
        }

        let vulnerabilities: Vec<vulnerabilities::ActiveModel> = result
            .vulnerabilities
            .iter()
            .map(|v| {
                let references_json = if v.references.is_empty() {
                    None
                } else {
                    Some(serde_json::to_value(&v.references).unwrap_or(serde_json::Value::Null))
                };

                vulnerabilities::ActiveModel {
                    id: NotSet,
                    scan_id: Set(scan_id),
                    vulnerability_id: Set(v.vulnerability_id.clone()),
                    package_name: Set(v.package_name.clone()),
                    installed_version: Set(v.installed_version.clone()),
                    fixed_version: Set(v.fixed_version.clone()),
                    severity: Set(v.severity.as_str().to_string()),
                    title: Set(v.title.clone()),
                    description: Set(v.description.clone()),
                    references: Set(references_json),
                    cvss_score: Set(v.cvss_score),
                    primary_url: Set(v.primary_url.clone()),
                    published_date: Set(v.published_date),
                    last_modified_date: Set(v.last_modified_date),
                    created_at: Set(chrono::Utc::now()),
                }
            })
            .collect();

        vulnerabilities::Entity::insert_many(vulnerabilities)
            .exec(self.db.as_ref())
            .await?;

        debug!(
            "Saved {} vulnerabilities for scan {}",
            result.vulnerabilities.len(),
            scan_id
        );

        Ok(())
    }

    /// Get a scan by ID
    pub async fn get_scan(&self, scan_id: i32) -> Result<vulnerability_scans::Model, ServiceError> {
        vulnerability_scans::Entity::find_by_id(scan_id)
            .one(self.db.as_ref())
            .await?
            .ok_or_else(|| ServiceError::NotFound(format!("Scan {} not found", scan_id)))
    }

    /// Get vulnerabilities for a scan
    pub async fn get_vulnerabilities(
        &self,
        scan_id: i32,
        severity_filter: Option<Severity>,
        page: Option<u64>,
        page_size: Option<u64>,
    ) -> Result<(Vec<vulnerabilities::Model>, u64), ServiceError> {
        let page = page.unwrap_or(1);
        let page_size = std::cmp::min(page_size.unwrap_or(20), 100);

        let mut query = vulnerabilities::Entity::find()
            .filter(vulnerabilities::Column::ScanId.eq(scan_id))
            .order_by(vulnerabilities::Column::CvssScore, Order::Desc)
            .order_by(vulnerabilities::Column::VulnerabilityId, Order::Asc);

        if let Some(severity) = severity_filter {
            query = query.filter(vulnerabilities::Column::Severity.eq(severity.as_str()));
        }

        let paginator = query.paginate(self.db.as_ref(), page_size);
        let total = paginator.num_items().await?;
        let items = paginator.fetch_page(page - 1).await?;

        Ok((items, total))
    }

    /// Get scans for a project
    pub async fn get_project_scans(
        &self,
        project_id: i32,
        page: Option<u64>,
        page_size: Option<u64>,
    ) -> Result<(Vec<vulnerability_scans::Model>, u64), ServiceError> {
        let page = page.unwrap_or(1);
        let page_size = std::cmp::min(page_size.unwrap_or(20), 100);

        let query = vulnerability_scans::Entity::find()
            .filter(vulnerability_scans::Column::ProjectId.eq(project_id))
            .order_by(vulnerability_scans::Column::CreatedAt, Order::Desc);

        let paginator = query.paginate(self.db.as_ref(), page_size);
        let total = paginator.num_items().await?;
        let items = paginator.fetch_page(page - 1).await?;

        Ok((items, total))
    }

    /// Get latest scan for a project
    pub async fn get_latest_scan(
        &self,
        project_id: i32,
        environment_id: Option<i32>,
    ) -> Result<Option<vulnerability_scans::Model>, ServiceError> {
        let mut query = vulnerability_scans::Entity::find()
            .filter(vulnerability_scans::Column::ProjectId.eq(project_id))
            .filter(vulnerability_scans::Column::Status.eq("completed"));

        if let Some(env_id) = environment_id {
            query = query.filter(vulnerability_scans::Column::EnvironmentId.eq(env_id));
        }

        let scan = query
            .order_by(vulnerability_scans::Column::CompletedAt, Order::Desc)
            .one(self.db.as_ref())
            .await?;

        Ok(scan)
    }

    /// Delete a scan and its vulnerabilities
    pub async fn delete_scan(&self, scan_id: i32) -> Result<(), ServiceError> {
        let scan = vulnerability_scans::Entity::find_by_id(scan_id)
            .one(self.db.as_ref())
            .await?
            .ok_or_else(|| ServiceError::NotFound(format!("Scan {} not found", scan_id)))?;

        vulnerability_scans::Entity::delete_by_id(scan.id)
            .exec(self.db.as_ref())
            .await?;

        info!("Deleted vulnerability scan {}", scan_id);

        Ok(())
    }

    /// Get scan by deployment_id
    /// Returns the vulnerability scan for a specific deployment
    pub async fn get_scan_by_deployment(
        &self,
        deployment_id: i32,
    ) -> Result<Option<vulnerability_scans::Model>, ServiceError> {
        let scan = vulnerability_scans::Entity::find()
            .filter(vulnerability_scans::Column::DeploymentId.eq(deployment_id))
            .filter(vulnerability_scans::Column::Status.eq("completed"))
            .one(self.db.as_ref())
            .await?;

        Ok(scan)
    }

    /// Get latest scans for current deployments per environment
    /// This fetches scans for the currently deployed version in each environment
    /// by looking up the environment's current_deployment_id
    pub async fn get_latest_scans_per_environment(
        &self,
        project_id: i32,
    ) -> Result<Vec<vulnerability_scans::Model>, ServiceError> {
        use sea_orm::{DatabaseBackend, FromQueryResult, Statement};

        #[derive(FromQueryResult)]
        struct ScanResult {
            id: i32,
            project_id: i32,
            environment_id: Option<i32>,
            deployment_id: Option<i32>,
            branch: Option<String>,
            commit_hash: Option<String>,
            scanner_type: String,
            scanner_version: Option<String>,
            status: String,
            total_count: i32,
            critical_count: i32,
            high_count: i32,
            medium_count: i32,
            low_count: i32,
            unknown_count: i32,
            error_message: Option<String>,
            started_at: chrono::DateTime<chrono::Utc>,
            completed_at: Option<chrono::DateTime<chrono::Utc>>,
            created_at: chrono::DateTime<chrono::Utc>,
            updated_at: chrono::DateTime<chrono::Utc>,
        }

        // Get scans for current deployments by joining with environments table
        let sql = r#"
            SELECT vs.*
            FROM vulnerability_scans vs
            INNER JOIN environments e ON vs.deployment_id = e.current_deployment_id
            WHERE e.project_id = $1
              AND vs.status = 'completed'
              AND e.deleted_at IS NULL
            ORDER BY e.id ASC
        "#;

        let scan_results: Vec<ScanResult> = ScanResult::find_by_statement(
            Statement::from_sql_and_values(DatabaseBackend::Postgres, sql, vec![project_id.into()]),
        )
        .all(self.db.as_ref())
        .await?;

        // Convert ScanResult to Model
        let scans = scan_results
            .into_iter()
            .map(|r| vulnerability_scans::Model {
                id: r.id,
                project_id: r.project_id,
                environment_id: r.environment_id,
                deployment_id: r.deployment_id,
                branch: r.branch,
                commit_hash: r.commit_hash,
                scanner_type: r.scanner_type,
                scanner_version: r.scanner_version,
                status: r.status,
                total_count: r.total_count,
                critical_count: r.critical_count,
                high_count: r.high_count,
                medium_count: r.medium_count,
                low_count: r.low_count,
                unknown_count: r.unknown_count,
                error_message: r.error_message,
                started_at: r.started_at,
                completed_at: r.completed_at,
                created_at: r.created_at,
                updated_at: r.updated_at,
            })
            .collect();

        Ok(scans)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::trivy::TrivyScanner;
    use sea_orm::Database;

    #[tokio::test]
    async fn test_service_creation() {
        let db = Database::connect("sqlite::memory:").await.unwrap();
        let scanner = Arc::new(TrivyScanner::new().unwrap());
        let service = VulnerabilityScanService::new(Arc::new(db), scanner);
        assert_eq!(service.scanner.name(), "trivy");
    }
}
