use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

use temps_core::plugin::{
    PluginContext, PluginError, PluginRoutes, ServiceRegistrationContext, TempsPlugin,
};
use tracing;
use utoipa::openapi::OpenApi;
use utoipa::OpenApi as OpenApiTrait;

use crate::{
    daily_scanner::DailyVulnerabilityScannerService,
    handlers::{self, create_vulnerability_scanner_app_state, VulnerabilityScannerAppState},
    service::VulnerabilityScanService,
    trivy::TrivyScanner,
};

/// Vulnerability Scanner Plugin for managing security scans
pub struct VulnerabilityScannerPlugin;

impl VulnerabilityScannerPlugin {
    pub fn new() -> Self {
        Self
    }
}

impl Default for VulnerabilityScannerPlugin {
    fn default() -> Self {
        Self::new()
    }
}

impl TempsPlugin for VulnerabilityScannerPlugin {
    fn name(&self) -> &'static str {
        "vulnerability-scanner"
    }

    fn register_services<'a>(
        &'a self,
        context: &'a ServiceRegistrationContext,
    ) -> Pin<Box<dyn Future<Output = Result<(), PluginError>> + Send + 'a>> {
        Box::pin(async move {
            // Get required dependencies from the service registry
            let db = context.require_service::<sea_orm::DatabaseConnection>();

            // Create Trivy scanner
            let scanner = Arc::new(TrivyScanner::new().map_err(|e| {
                PluginError::InitializationFailed(format!("Failed to create Trivy scanner: {}", e))
            })?);

            // Get optional JobQueue from service registry
            let queue = context.get_service::<dyn temps_core::jobs::JobQueue>();

            // Create VulnerabilityScanService with queue if available
            let scan_service = if let Some(queue) = queue {
                tracing::debug!("JobQueue found, enabling scan completion notifications");
                Arc::new(VulnerabilityScanService::with_queue(
                    db.clone(),
                    scanner,
                    queue,
                ))
            } else {
                tracing::debug!("JobQueue not found, scan notifications will not be sent");
                Arc::new(VulnerabilityScanService::new(db.clone(), scanner))
            };

            context.register_service(scan_service.clone());

            // Create and start daily vulnerability scanner
            let daily_scanner =
                DailyVulnerabilityScannerService::new(db.clone(), scan_service.clone());

            // Spawn background task for daily scanner
            tokio::spawn(async move {
                tracing::info!("Starting daily vulnerability scanner service");
                daily_scanner.start().await;
            });

            // Get AuditService dependency from other plugins
            let audit_service = context.require_service::<dyn temps_core::AuditLogger>();

            // Create VulnerabilityScannerAppState for handlers
            let scanner_app_state =
                create_vulnerability_scanner_app_state(scan_service, audit_service, db).await;
            context.register_service(scanner_app_state);

            tracing::debug!("Vulnerability Scanner plugin services registered successfully");
            Ok(())
        })
    }

    fn configure_routes(&self, context: &PluginContext) -> Option<PluginRoutes> {
        // Get the VulnerabilityScannerAppState (returns Arc<Arc> because .into() wrapped it)
        let scanner_app_state = context.require_service::<VulnerabilityScannerAppState>();

        // Configure routes - pass Arc directly
        let scanner_routes = handlers::configure_routes().with_state(scanner_app_state);

        Some(PluginRoutes {
            router: scanner_routes,
        })
    }

    fn openapi_schema(&self) -> Option<OpenApi> {
        Some(<handlers::scans_handler::ScansApiDoc as OpenApiTrait>::openapi())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_vulnerability_scanner_plugin_name() {
        let plugin = VulnerabilityScannerPlugin::new();
        assert_eq!(plugin.name(), "vulnerability-scanner");
    }

    #[tokio::test]
    async fn test_vulnerability_scanner_plugin_default() {
        let plugin = VulnerabilityScannerPlugin;
        assert_eq!(plugin.name(), "vulnerability-scanner");
    }
}
