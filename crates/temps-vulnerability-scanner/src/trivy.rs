use crate::scanner::{ScanResult, ScannerError, Severity, Vulnerability, VulnerabilityScanner};
use async_trait::async_trait;
use bollard::container::LogOutput;
use bollard::models::{
    ContainerCreateBody, ContainerWaitResponse, HostConfig, Mount, MountTypeEnum,
};
use bollard::query_parameters::{
    CreateContainerOptions, CreateImageOptions, LogsOptions, RemoveContainerOptions,
    StartContainerOptions, WaitContainerOptions,
};
use bollard::Docker;
use chrono::DateTime;
use futures::StreamExt;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use tracing::{debug, error, info, warn};

const TRIVY_IMAGE: &str = "aquasec/trivy:0.58.1";
const TRIVY_TIMEOUT_SECONDS: i64 = 600; // 10 minutes

/// Trivy scanner implementation
pub struct TrivyScanner {
    docker: Docker,
}

impl TrivyScanner {
    pub fn new() -> Result<Self, ScannerError> {
        let docker = Docker::connect_with_local_defaults().map_err(|e| {
            ScannerError::Initialization(format!("Failed to connect to Docker: {}", e))
        })?;

        Ok(Self { docker })
    }

    /// Pull Trivy image if not available
    async fn ensure_image(&self) -> Result<(), ScannerError> {
        // Check if image exists
        match self.docker.inspect_image(TRIVY_IMAGE).await {
            Ok(_) => {
                debug!("Trivy image already exists locally");
                return Ok(());
            }
            Err(_) => {
                info!("Trivy image not found locally, pulling...");
            }
        }

        // Pull the image
        let mut stream = self.docker.create_image(
            Some(CreateImageOptions {
                from_image: Some(TRIVY_IMAGE.to_string()),
                ..Default::default()
            }),
            None,
            None,
        );

        while let Some(result) = stream.next().await {
            match result {
                Ok(info) => {
                    if let Some(status) = info.status {
                        debug!("Pull status: {}", status);
                    }
                }
                Err(e) => {
                    return Err(ScannerError::Docker(e));
                }
            }
        }

        info!("Trivy image pulled successfully");
        Ok(())
    }

    /// Parse Trivy JSON output
    fn parse_trivy_output(&self, json_output: &str) -> Result<ScanResult, ScannerError> {
        let trivy_report: TrivyReport = serde_json::from_str(json_output)
            .map_err(|e| ScannerError::Parsing(format!("Failed to parse Trivy JSON: {}", e)))?;

        let scanner_version = trivy_report
            .metadata
            .as_ref()
            .and_then(|m| m.version.clone());

        let mut result = ScanResult::new("trivy".to_string(), scanner_version);

        for trivy_result in trivy_report.results {
            if let Some(vulnerabilities) = trivy_result.vulnerabilities {
                for vuln in vulnerabilities {
                    let vuln_id = vuln.vulnerability_id.clone();
                    result.add_vulnerability(Vulnerability {
                        vulnerability_id: vuln.vulnerability_id,
                        package_name: vuln.pkg_name,
                        installed_version: vuln.installed_version,
                        fixed_version: vuln.fixed_version,
                        severity: parse_severity(&vuln.severity),
                        title: vuln.title.unwrap_or(vuln_id),
                        description: vuln.description,
                        references: vuln.references.unwrap_or_default(),
                        cvss_score: vuln
                            .cvss
                            .and_then(|cvss| cvss.values().next().and_then(|v| v.v3_score)),
                        primary_url: vuln.primary_url,
                        published_date: vuln
                            .published_date
                            .and_then(|s| DateTime::parse_from_rfc3339(&s).ok())
                            .map(|dt| dt.with_timezone(&chrono::Utc)),
                        last_modified_date: vuln
                            .last_modified_date
                            .and_then(|s| DateTime::parse_from_rfc3339(&s).ok())
                            .map(|dt| dt.with_timezone(&chrono::Utc)),
                        class: trivy_result.class.clone(),
                        vuln_type: trivy_result.result_type.clone(),
                        target: Some(trivy_result.target.clone()),
                    });
                }
            }
        }

        Ok(result)
    }
}

#[async_trait]
impl VulnerabilityScanner for TrivyScanner {
    fn name(&self) -> &str {
        "trivy"
    }

    async fn version(&self) -> Result<Option<String>, ScannerError> {
        self.ensure_image().await?;

        let container_name = format!("trivy-version-{}", uuid::Uuid::new_v4());

        let config = ContainerCreateBody {
            image: Some(TRIVY_IMAGE.to_string()),
            cmd: Some(vec!["--version".to_string()]),
            ..Default::default()
        };

        let container = self
            .docker
            .create_container(
                Some(CreateContainerOptions {
                    name: Some(container_name.clone()),
                    ..Default::default()
                }),
                config,
            )
            .await?;

        self.docker
            .start_container(&container.id, None::<StartContainerOptions>)
            .await?;

        // Wait for container to finish
        let mut wait_stream = self.docker.wait_container(
            &container.id,
            Some(WaitContainerOptions {
                condition: "not-running".to_string(),
            }),
        );

        if let Some(result) = wait_stream.next().await {
            result?;
        }

        // Get logs
        let mut logs_stream = self.docker.logs(
            &container.id,
            Some(LogsOptions {
                stdout: true,
                stderr: true,
                ..Default::default()
            }),
        );

        let mut output = String::new();
        while let Some(log_result) = logs_stream.next().await {
            match log_result {
                Ok(LogOutput::StdOut { message }) | Ok(LogOutput::StdErr { message }) => {
                    output.push_str(&String::from_utf8_lossy(&message));
                }
                _ => {}
            }
        }

        // Cleanup
        self.docker
            .remove_container(
                &container.id,
                Some(RemoveContainerOptions {
                    force: true,
                    ..Default::default()
                }),
            )
            .await
            .ok();

        // Parse version from output (e.g., "Version: 0.48.0")
        let version = output
            .lines()
            .find(|line| line.contains("Version:"))
            .and_then(|line| line.split(':').nth(1))
            .map(|v| v.trim().to_string());

        Ok(version)
    }

    async fn scan_path(&self, path: &Path) -> Result<ScanResult, ScannerError> {
        self.ensure_image().await?;

        let abs_path = path.canonicalize().map_err(|e| ScannerError::Io(e))?;

        let container_name = format!("trivy-scan-{}", uuid::Uuid::new_v4());

        info!("Starting Trivy scan for path: {}", abs_path.display());

        // Create container with mounted volume
        let config = ContainerCreateBody {
            image: Some(TRIVY_IMAGE.to_string()),
            cmd: Some(vec![
                "fs".to_string(),
                "--format".to_string(),
                "json".to_string(),
                "--timeout".to_string(),
                format!("{}s", TRIVY_TIMEOUT_SECONDS),
                "/scan".to_string(),
            ]),
            host_config: Some(HostConfig {
                mounts: Some(vec![Mount {
                    target: Some("/scan".to_string()),
                    source: Some(abs_path.to_string_lossy().to_string()),
                    typ: Some(MountTypeEnum::BIND),
                    read_only: Some(true),
                    ..Default::default()
                }]),
                ..Default::default()
            }),
            ..Default::default()
        };

        let container = self
            .docker
            .create_container(
                Some(CreateContainerOptions {
                    name: Some(container_name.clone()),
                    ..Default::default()
                }),
                config,
            )
            .await?;

        debug!("Created container: {}", container.id);

        // Start the container
        self.docker
            .start_container(&container.id, None::<StartContainerOptions>)
            .await?;

        debug!("Started container");

        // Wait for container to finish
        let mut wait_stream = self.docker.wait_container(
            &container.id,
            Some(WaitContainerOptions {
                condition: "not-running".to_string(),
            }),
        );

        let wait_result: Option<Result<ContainerWaitResponse, bollard::errors::Error>> =
            wait_stream.next().await;

        match wait_result {
            Some(Ok(response)) => {
                debug!(
                    "Container finished with status code: {:?}",
                    response.status_code
                );
            }
            Some(Err(e)) => {
                warn!("Error waiting for container: {}", e);
            }
            None => {
                warn!("Wait stream ended without result");
            }
        }

        // Get logs (stdout contains JSON output)
        let mut logs_stream = self.docker.logs(
            &container.id,
            Some(LogsOptions {
                stdout: true,
                stderr: false,
                ..Default::default()
            }),
        );

        let mut json_output = String::new();
        while let Some(log_result) = logs_stream.next().await {
            match log_result {
                Ok(LogOutput::StdOut { message }) => {
                    json_output.push_str(&String::from_utf8_lossy(&message));
                }
                Ok(LogOutput::StdErr { message }) => {
                    let stderr = String::from_utf8_lossy(&message);
                    if !stderr.trim().is_empty() {
                        debug!("Trivy stderr: {}", stderr);
                    }
                }
                Err(e) => {
                    error!("Error reading logs: {}", e);
                }
                _ => {}
            }
        }

        // Cleanup container
        self.docker
            .remove_container(
                &container.id,
                Some(RemoveContainerOptions {
                    force: true,
                    ..Default::default()
                }),
            )
            .await
            .ok();

        if json_output.trim().is_empty() {
            return Err(ScannerError::Execution(
                "Trivy scan produced no output".to_string(),
            ));
        }

        // Parse the JSON output
        self.parse_trivy_output(&json_output)
    }

    async fn scan_image(&self, image_name: &str) -> Result<ScanResult, ScannerError> {
        self.ensure_image().await?;

        // Verify the target image exists locally
        self.docker.inspect_image(image_name).await.map_err(|e| {
            ScannerError::Execution(format!(
                "Target image '{}' not found locally: {}",
                image_name, e
            ))
        })?;

        let container_name = format!("trivy-image-scan-{}", uuid::Uuid::new_v4());

        info!("Starting Trivy image scan for: {}", image_name);

        // Create container to scan Docker image
        // Trivy needs access to the Docker socket to scan images
        let config = ContainerCreateBody {
            image: Some(TRIVY_IMAGE.to_string()),
            cmd: Some(vec![
                "image".to_string(),
                "--format".to_string(),
                "json".to_string(),
                "--timeout".to_string(),
                format!("{}s", TRIVY_TIMEOUT_SECONDS),
                image_name.to_string(),
            ]),
            host_config: Some(HostConfig {
                // Mount Docker socket so Trivy can access local images
                mounts: Some(vec![Mount {
                    target: Some("/var/run/docker.sock".to_string()),
                    source: Some("/var/run/docker.sock".to_string()),
                    typ: Some(MountTypeEnum::BIND),
                    read_only: Some(false), // Trivy needs read-write access to Docker socket
                    ..Default::default()
                }]),
                ..Default::default()
            }),
            ..Default::default()
        };

        let container = self
            .docker
            .create_container(
                Some(CreateContainerOptions {
                    name: Some(container_name.clone()),
                    ..Default::default()
                }),
                config,
            )
            .await?;

        debug!("Created Trivy container: {}", container.id);

        // Start the container
        self.docker
            .start_container(&container.id, None::<StartContainerOptions>)
            .await?;

        debug!("Started Trivy container");

        // Wait for container to finish
        let mut wait_stream = self.docker.wait_container(
            &container.id,
            Some(WaitContainerOptions {
                condition: "not-running".to_string(),
            }),
        );

        let wait_result: Option<Result<ContainerWaitResponse, bollard::errors::Error>> =
            wait_stream.next().await;

        match wait_result {
            Some(Ok(response)) => {
                debug!(
                    "Trivy container finished with status code: {:?}",
                    response.status_code
                );
            }
            Some(Err(e)) => {
                warn!("Error waiting for Trivy container: {}", e);
            }
            None => {
                warn!("Wait stream ended without result");
            }
        }

        // Get logs (stdout contains JSON output)
        let mut logs_stream = self.docker.logs(
            &container.id,
            Some(LogsOptions {
                stdout: true,
                stderr: false,
                ..Default::default()
            }),
        );

        let mut json_output = String::new();
        while let Some(log_result) = logs_stream.next().await {
            match log_result {
                Ok(LogOutput::StdOut { message }) => {
                    json_output.push_str(&String::from_utf8_lossy(&message));
                }
                Ok(LogOutput::StdErr { message }) => {
                    let stderr = String::from_utf8_lossy(&message);
                    if !stderr.trim().is_empty() {
                        debug!("Trivy stderr: {}", stderr);
                    }
                }
                Err(e) => {
                    error!("Error reading Trivy logs: {}", e);
                }
                _ => {}
            }
        }

        // Cleanup container
        self.docker
            .remove_container(
                &container.id,
                Some(RemoveContainerOptions {
                    force: true,
                    ..Default::default()
                }),
            )
            .await
            .ok();

        if json_output.trim().is_empty() {
            return Err(ScannerError::Execution(
                "Trivy image scan produced no output".to_string(),
            ));
        }

        // Parse the JSON output
        self.parse_trivy_output(&json_output)
    }

    async fn is_available(&self) -> bool {
        self.docker.inspect_image(TRIVY_IMAGE).await.is_ok()
    }
}

fn parse_severity(severity: &str) -> Severity {
    match severity.to_uppercase().as_str() {
        "CRITICAL" => Severity::Critical,
        "HIGH" => Severity::High,
        "MEDIUM" => Severity::Medium,
        "LOW" => Severity::Low,
        _ => Severity::Unknown,
    }
}

// Trivy JSON output structures
#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "PascalCase")]
struct TrivyReport {
    #[serde(default)]
    results: Vec<TrivyResult>,
    #[serde(rename = "Metadata")]
    metadata: Option<TrivyMetadata>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "PascalCase")]
struct TrivyMetadata {
    #[serde(rename = "Version")]
    version: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "PascalCase")]
struct TrivyResult {
    target: String,
    #[serde(rename = "Class")]
    class: Option<String>,
    #[serde(rename = "Type")]
    result_type: Option<String>,
    vulnerabilities: Option<Vec<TrivyVulnerability>>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "PascalCase")]
struct TrivyVulnerability {
    #[serde(rename = "VulnerabilityID")]
    vulnerability_id: String,
    #[serde(rename = "PkgName")]
    pkg_name: String,
    installed_version: String,
    fixed_version: Option<String>,
    severity: String,
    title: Option<String>,
    description: Option<String>,
    references: Option<Vec<String>>,
    #[serde(rename = "PrimaryURL")]
    primary_url: Option<String>,
    published_date: Option<String>,
    last_modified_date: Option<String>,
    #[serde(rename = "CVSS")]
    cvss: Option<HashMap<String, CvssInfo>>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "PascalCase")]
struct CvssInfo {
    #[serde(rename = "V3Score")]
    v3_score: Option<f32>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_trivy_scanner_creation() {
        let scanner = TrivyScanner::new();
        assert!(scanner.is_ok());
    }

    #[tokio::test]
    async fn test_scanner_name() {
        let scanner = TrivyScanner::new().unwrap();
        assert_eq!(scanner.name(), "trivy");
    }
}
