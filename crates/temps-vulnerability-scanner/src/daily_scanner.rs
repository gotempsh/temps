//! Daily Vulnerability Scanner
//!
//! Automatically scans all deployed environments daily for security vulnerabilities

use chrono::{Timelike, Utc};
use sea_orm::{ColumnTrait, EntityTrait, QueryFilter};
use std::sync::Arc;
use temps_database::DbConnection;
use temps_entities::{deployments, environments};
use tokio::time::{self, Duration};
use tracing::{debug, error, info, warn};

use crate::service::VulnerabilityScanService;

/// Service that runs daily vulnerability scans on all deployed environments
pub struct DailyVulnerabilityScannerService {
    db: Arc<DbConnection>,
    scan_service: Arc<VulnerabilityScanService>,
}

impl DailyVulnerabilityScannerService {
    pub fn new(db: Arc<DbConnection>, scan_service: Arc<VulnerabilityScanService>) -> Self {
        Self { db, scan_service }
    }

    /// Start the daily scanner background task
    pub async fn start(&self) {
        info!("Starting daily vulnerability scanner service");

        loop {
            let now = Utc::now();

            // Run at midnight UTC every day (00:00:00)
            if now.hour() == 0 && now.minute() == 0 && now.second() < 60 {
                info!("Starting daily vulnerability scan for all deployments");

                if let Err(e) = self.scan_all_deployed_environments().await {
                    error!("Failed to complete daily vulnerability scan: {}", e);
                }

                // Sleep for 2 minutes to avoid running multiple times in the same minute
                time::sleep(Duration::from_secs(120)).await;
            }

            // Sleep until next minute
            let next_minute = now
                .with_second(0)
                .and_then(|dt| dt.with_nanosecond(0))
                .unwrap()
                + chrono::Duration::minutes(1);

            let sleep_duration = (next_minute - now)
                .to_std()
                .unwrap_or(Duration::from_secs(60));

            time::sleep(sleep_duration).await;
        }
    }

    /// Scan all environments with current deployments
    async fn scan_all_deployed_environments(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Get all environments with current deployments
        let environments_with_deployments = environments::Entity::find()
            .filter(environments::Column::CurrentDeploymentId.is_not_null())
            .filter(environments::Column::DeletedAt.is_null())
            .all(self.db.as_ref())
            .await?;

        info!(
            "Found {} environments with current deployments to scan",
            environments_with_deployments.len()
        );

        let mut scans_triggered = 0;
        let mut scans_failed = 0;

        for env in environments_with_deployments {
            let deployment_id = match env.current_deployment_id {
                Some(id) => id,
                None => {
                    warn!("Environment {} has no current deployment, skipping", env.id);
                    continue;
                }
            };

            // Fetch deployment to get image and metadata
            let deployment = match deployments::Entity::find_by_id(deployment_id)
                .one(self.db.as_ref())
                .await?
            {
                Some(d) => d,
                None => {
                    warn!(
                        "Deployment {} for environment {} not found, skipping",
                        deployment_id, env.id
                    );
                    continue;
                }
            };

            let image_name = match &deployment.image_name {
                Some(name) => name.clone(),
                None => {
                    warn!("Deployment {} has no image name, skipping", deployment_id);
                    continue;
                }
            };

            info!(
                "Triggering scan for project {} environment {} (deployment {}, image: {})",
                env.project_id, env.id, deployment_id, image_name
            );

            // Create scan record
            let scan = match self
                .scan_service
                .create_scan(
                    env.project_id,
                    Some(env.id),
                    Some(deployment_id),
                    deployment.branch_ref.clone(),
                    deployment.commit_sha.clone(),
                )
                .await
            {
                Ok(s) => s,
                Err(e) => {
                    error!(
                        "Failed to create scan for environment {} deployment {}: {}",
                        env.id, deployment_id, e
                    );
                    scans_failed += 1;
                    continue;
                }
            };

            // Execute scan asynchronously (spawn task to avoid blocking)
            let scan_service = self.scan_service.clone();
            let scan_id = scan.id;
            let image_for_scan = image_name.clone();
            let env_id = env.id;

            tokio::spawn(async move {
                debug!("Executing scan {} for environment {}", scan_id, env_id);

                match scan_service
                    .execute_image_scan(scan_id, &image_for_scan)
                    .await
                {
                    Ok(result) => {
                        info!(
                            "Daily scan {} completed for environment {}: {} vulnerabilities found ({} critical, {} high)",
                            scan_id,
                            env_id,
                            result.total_count,
                            result.critical_count,
                            result.high_count
                        );
                    }
                    Err(e) => {
                        error!(
                            "Daily scan {} failed for environment {}: {}",
                            scan_id, env_id, e
                        );
                    }
                }
            });

            scans_triggered += 1;

            // Add small delay between triggering scans to avoid overwhelming the system
            time::sleep(Duration::from_millis(500)).await;
        }

        info!(
            "Daily vulnerability scan completed: {} scans triggered, {} failed",
            scans_triggered, scans_failed
        );

        Ok(())
    }
}
