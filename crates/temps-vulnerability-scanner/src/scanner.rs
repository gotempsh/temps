use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::path::Path;
use thiserror::Error;
use utoipa::ToSchema;

#[derive(Error, Debug)]
pub enum ScannerError {
    #[error("Scanner initialization error: {0}")]
    Initialization(String),

    #[error("Scan execution error: {0}")]
    Execution(String),

    #[error("Result parsing error: {0}")]
    Parsing(String),

    #[error("Docker error: {0}")]
    Docker(#[from] bollard::errors::Error),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("JSON parsing error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("Internal error: {0}")]
    Internal(String),
}

/// Severity level of a vulnerability
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, ToSchema)]
#[serde(rename_all = "UPPERCASE")]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Unknown,
}

impl Severity {
    pub fn as_str(&self) -> &'static str {
        match self {
            Severity::Critical => "CRITICAL",
            Severity::High => "HIGH",
            Severity::Medium => "MEDIUM",
            Severity::Low => "LOW",
            Severity::Unknown => "UNKNOWN",
        }
    }
}

/// Represents a single vulnerability finding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier (e.g., CVE-2021-1234)
    pub vulnerability_id: String,

    /// Package or resource affected
    pub package_name: String,

    /// Version of the package
    pub installed_version: String,

    /// Fixed version (if available)
    pub fixed_version: Option<String>,

    /// Severity level
    pub severity: Severity,

    /// Human-readable title or summary
    pub title: String,

    /// Detailed description
    pub description: Option<String>,

    /// References (URLs to CVE databases, advisories, etc.)
    pub references: Vec<String>,

    /// CVSS score (if available)
    pub cvss_score: Option<f32>,

    /// Primary URL for more information
    pub primary_url: Option<String>,

    /// Published date
    pub published_date: Option<chrono::DateTime<chrono::Utc>>,

    /// Last modified date
    pub last_modified_date: Option<chrono::DateTime<chrono::Utc>>,
}

/// Result of a vulnerability scan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// List of vulnerabilities found
    pub vulnerabilities: Vec<Vulnerability>,

    /// Total count of vulnerabilities
    pub total_count: usize,

    /// Count by severity
    pub critical_count: usize,
    pub high_count: usize,
    pub medium_count: usize,
    pub low_count: usize,
    pub unknown_count: usize,

    /// Scan metadata
    pub scanned_at: chrono::DateTime<chrono::Utc>,

    /// Scanner type used
    pub scanner_type: String,

    /// Scanner version
    pub scanner_version: Option<String>,
}

impl ScanResult {
    pub fn new(scanner_type: String, scanner_version: Option<String>) -> Self {
        Self {
            vulnerabilities: Vec::new(),
            total_count: 0,
            critical_count: 0,
            high_count: 0,
            medium_count: 0,
            low_count: 0,
            unknown_count: 0,
            scanned_at: chrono::Utc::now(),
            scanner_type,
            scanner_version,
        }
    }

    pub fn add_vulnerability(&mut self, vuln: Vulnerability) {
        match vuln.severity {
            Severity::Critical => self.critical_count += 1,
            Severity::High => self.high_count += 1,
            Severity::Medium => self.medium_count += 1,
            Severity::Low => self.low_count += 1,
            Severity::Unknown => self.unknown_count += 1,
        }
        self.total_count += 1;
        self.vulnerabilities.push(vuln);
    }
}

/// Trait for vulnerability scanners
#[async_trait]
pub trait VulnerabilityScanner: Send + Sync {
    /// Returns the scanner name
    fn name(&self) -> &str;

    /// Returns the scanner version (if available)
    async fn version(&self) -> Result<Option<String>, ScannerError>;

    /// Scan a filesystem path for vulnerabilities
    async fn scan_path(&self, path: &Path) -> Result<ScanResult, ScannerError>;

    /// Scan a Docker image for vulnerabilities
    ///
    /// # Arguments
    /// * `image_name` - Full Docker image name with tag (e.g., "myapp:latest" or "sha256:abc123...")
    async fn scan_image(&self, image_name: &str) -> Result<ScanResult, ScannerError>;

    /// Check if the scanner is available (e.g., Docker image exists)
    async fn is_available(&self) -> bool;
}
