use crate::scanner::Severity;
use crate::service::ServiceError;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    routing::get,
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use temps_auth::permission_guard;
use temps_auth::RequireAuth;
use temps_core::problemdetails;
use temps_core::problemdetails::{Problem, ProblemDetails};
use tracing::{error, info};
use utoipa::{OpenApi, ToSchema};

use super::VulnerabilityScannerAppState;

impl From<ServiceError> for Problem {
    fn from(error: ServiceError) -> Self {
        match error {
            ServiceError::Database(e) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Database Error")
                .with_detail(e.to_string()),

            ServiceError::Scanner(e) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Scanner Error")
                .with_detail(e.to_string()),

            ServiceError::NotFound(msg) => problemdetails::new(StatusCode::NOT_FOUND)
                .with_title("Resource Not Found")
                .with_detail(msg),

            ServiceError::InvalidStatus(msg) => problemdetails::new(StatusCode::BAD_REQUEST)
                .with_title("Invalid Status")
                .with_detail(msg),

            ServiceError::Internal(msg) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Internal Server Error")
                .with_detail(msg),
        }
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(
        list_project_scans,
        trigger_scan,
        get_scan,
        get_scan_vulnerabilities,
        get_latest_scan,
        get_latest_scans_per_environment,
        get_scan_by_deployment,
        delete_scan
    ),
    components(
        schemas(
            ScanResponse,
            VulnerabilityResponse,
            ListScansQuery,
            ListVulnerabilitiesQuery,
            TriggerScanRequest,
            TriggerScanResponse,
        )
    ),
    info(
        title = "Vulnerability Scanner API",
        description = "API endpoints for managing vulnerability scans. \
        Provides endpoints to view scan results, vulnerabilities, and scan history.",
        version = "1.0.0"
    ),
    tags(
        (name = "Vulnerability Scans", description = "Vulnerability scan management endpoints")
    )
)]
pub struct ScansApiDoc;

#[derive(Serialize, ToSchema)]
pub struct ScanResponse {
    pub id: i32,
    pub project_id: i32,
    pub environment_id: Option<i32>,
    pub deployment_id: Option<i32>,
    pub branch: Option<String>,
    pub commit_hash: Option<String>,
    pub scanner_type: String,
    pub scanner_version: Option<String>,
    pub status: String,
    pub total_count: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub unknown_count: i32,
    pub error_message: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub started_at: String,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub completed_at: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub created_at: String,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub updated_at: String,
}

impl From<temps_entities::vulnerability_scans::Model> for ScanResponse {
    fn from(scan: temps_entities::vulnerability_scans::Model) -> Self {
        Self {
            id: scan.id,
            project_id: scan.project_id,
            environment_id: scan.environment_id,
            deployment_id: scan.deployment_id,
            branch: scan.branch,
            commit_hash: scan.commit_hash,
            scanner_type: scan.scanner_type,
            scanner_version: scan.scanner_version,
            status: scan.status,
            total_count: scan.total_count,
            critical_count: scan.critical_count,
            high_count: scan.high_count,
            medium_count: scan.medium_count,
            low_count: scan.low_count,
            unknown_count: scan.unknown_count,
            error_message: scan.error_message,
            started_at: scan.started_at.to_rfc3339(),
            completed_at: scan.completed_at.map(|dt| dt.to_rfc3339()),
            created_at: scan.created_at.to_rfc3339(),
            updated_at: scan.updated_at.to_rfc3339(),
        }
    }
}

#[derive(Serialize, ToSchema)]
pub struct VulnerabilityResponse {
    pub id: i32,
    pub scan_id: i32,
    pub vulnerability_id: String,
    pub package_name: String,
    pub installed_version: String,
    pub fixed_version: Option<String>,
    pub severity: String,
    pub title: String,
    pub description: Option<String>,
    pub references: Option<serde_json::Value>,
    pub cvss_score: Option<f32>,
    pub primary_url: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub published_date: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub last_modified_date: Option<String>,
    #[schema(example = "os-pkgs")]
    pub class: Option<String>,
    #[serde(rename = "type")]
    #[schema(example = "alpine")]
    pub vuln_type: Option<String>,
    #[schema(example = "alpine:3.18 (alpine 3.18.0)")]
    pub target: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub created_at: String,
}

impl From<temps_entities::vulnerabilities::Model> for VulnerabilityResponse {
    fn from(vuln: temps_entities::vulnerabilities::Model) -> Self {
        Self {
            id: vuln.id,
            scan_id: vuln.scan_id,
            vulnerability_id: vuln.vulnerability_id,
            package_name: vuln.package_name,
            installed_version: vuln.installed_version,
            fixed_version: vuln.fixed_version,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            references: vuln.references,
            cvss_score: vuln.cvss_score,
            primary_url: vuln.primary_url,
            published_date: vuln.published_date.map(|dt| dt.to_rfc3339()),
            last_modified_date: vuln.last_modified_date.map(|dt| dt.to_rfc3339()),
            class: vuln.class,
            vuln_type: vuln.vuln_type,
            target: vuln.target,
            created_at: vuln.created_at.to_rfc3339(),
        }
    }
}

#[derive(Deserialize, ToSchema)]
pub struct ListScansQuery {
    #[schema(example = 1)]
    pub page: Option<u64>,
    #[schema(example = 20)]
    pub page_size: Option<u64>,
}

#[derive(Deserialize, ToSchema)]
pub struct ListVulnerabilitiesQuery {
    #[schema(example = 1)]
    pub page: Option<u64>,
    #[schema(example = 20)]
    pub page_size: Option<u64>,
    #[schema(example = "CRITICAL")]
    pub severity: Option<String>,
}

#[derive(Deserialize, ToSchema)]
pub struct TriggerScanRequest {
    /// Environment ID to scan (uses the current deployment for this environment)
    #[schema(example = 1)]
    pub environment_id: i32,
}

#[derive(Serialize, ToSchema)]
pub struct TriggerScanResponse {
    pub scan_id: i32,
    pub status: String,
    pub message: String,
}

pub fn configure_routes() -> Router<Arc<VulnerabilityScannerAppState>> {
    Router::new()
        .route(
            "/projects/{project_id}/vulnerability-scans",
            get(list_project_scans).post(trigger_scan),
        )
        .route(
            "/projects/{project_id}/vulnerability-scans/latest",
            get(get_latest_scan),
        )
        .route(
            "/projects/{project_id}/vulnerability-scans/environments",
            get(get_latest_scans_per_environment),
        )
        .route(
            "/deployments/{deployment_id}/vulnerability-scan",
            get(get_scan_by_deployment),
        )
        .route(
            "/vulnerability-scans/{scan_id}",
            get(get_scan).delete(delete_scan),
        )
        .route(
            "/vulnerability-scans/{scan_id}/vulnerabilities",
            get(get_scan_vulnerabilities),
        )
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/projects/{project_id}/vulnerability-scans",
    params(
        ("project_id" = i32, Path, description = "Project ID"),
        ("page" = Option<u64>, Query, description = "Page number (default: 1)"),
        ("page_size" = Option<u64>, Query, description = "Page size (default: 20, max: 100)"),
    ),
    responses(
        (status = 200, description = "List of vulnerability scans", body = Vec<ScanResponse>),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn list_project_scans(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
    Query(query): Query<ListScansQuery>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let (scans, total) = app_state
        .scan_service
        .get_project_scans(project_id, query.page, query.page_size)
        .await?;

    let responses: Vec<ScanResponse> = scans.into_iter().map(Into::into).collect();

    Ok(Json(serde_json::json!({
        "data": responses,
        "total": total,
        "page": query.page.unwrap_or(1),
        "page_size": query.page_size.unwrap_or(20),
    })))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    post,
    path = "/projects/{project_id}/vulnerability-scans",
    request_body = TriggerScanRequest,
    params(
        ("project_id" = i32, Path, description = "Project ID"),
    ),
    responses(
        (status = 202, description = "Scan triggered successfully", body = TriggerScanResponse),
        (status = 400, description = "Invalid request", body = ProblemDetails),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn trigger_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
    Json(request): Json<TriggerScanRequest>,
) -> Result<impl IntoResponse, Problem> {
    use sea_orm::EntityTrait;
    use temps_entities::{deployments, environments};

    permission_guard!(auth, VulnerabilityScansCreate);

    // Fetch environment to get current deployment
    let environment = environments::Entity::find_by_id(request.environment_id)
        .one(app_state.db.as_ref())
        .await
        .map_err(|e| {
            Problem::from(ServiceError::Internal(format!(
                "Failed to fetch environment: {}",
                e
            )))
        })?
        .ok_or_else(|| {
            Problem::from(ServiceError::NotFound(format!(
                "Environment {} not found",
                request.environment_id
            )))
        })?;

    // Verify environment belongs to the project
    if environment.project_id != project_id {
        return Err(Problem::from(ServiceError::NotFound(format!(
            "Environment {} does not belong to project {}",
            request.environment_id, project_id
        ))));
    }

    // Get current deployment for this environment
    let deployment_id = environment.current_deployment_id.ok_or_else(|| {
        Problem::from(ServiceError::NotFound(format!(
            "No current deployment found for environment {}",
            request.environment_id
        )))
    })?;

    // Fetch deployment to get image and metadata
    let deployment = deployments::Entity::find_by_id(deployment_id)
        .one(app_state.db.as_ref())
        .await
        .map_err(|e| {
            Problem::from(ServiceError::Internal(format!(
                "Failed to fetch deployment: {}",
                e
            )))
        })?
        .ok_or_else(|| {
            Problem::from(ServiceError::NotFound(format!(
                "Deployment {} not found",
                deployment_id
            )))
        })?;

    let image_name = deployment.image_name.clone().ok_or_else(|| {
        Problem::from(ServiceError::NotFound(format!(
            "Deployment {} has no image name",
            deployment_id
        )))
    })?;

    // Create scan record
    let scan = app_state
        .scan_service
        .create_scan(
            project_id,
            Some(request.environment_id),
            Some(deployment_id),
            deployment.branch_ref.clone(),
            deployment.commit_sha.clone(),
        )
        .await?;

    // Execute scan asynchronously (spawn task to avoid blocking)
    let scan_service = app_state.scan_service.clone();
    let scan_id = scan.id;
    let image_for_scan = image_name.clone();

    tokio::spawn(async move {
        match scan_service
            .execute_image_scan(scan_id, &image_for_scan)
            .await
        {
            Ok(_) => {
                info!("Manual scan {} completed successfully", scan_id);
            }
            Err(e) => {
                error!("Manual scan {} failed: {}", scan_id, e);
            }
        }
    });

    Ok((
        StatusCode::ACCEPTED,
        Json(TriggerScanResponse {
            scan_id: scan.id,
            status: "pending".to_string(),
            message: format!(
                "Vulnerability scan triggered for deployment {} (image: {}). Scan ID: {}",
                deployment_id, image_name, scan.id
            ),
        }),
    ))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/vulnerability-scans/{scan_id}",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
    ),
    responses(
        (status = 200, description = "Scan details", body = ScanResponse),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let scan = app_state.scan_service.get_scan(scan_id).await?;

    Ok(Json(ScanResponse::from(scan)))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/vulnerability-scans/{scan_id}/vulnerabilities",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
        ("page" = Option<u64>, Query, description = "Page number (default: 1)"),
        ("page_size" = Option<u64>, Query, description = "Page size (default: 20, max: 100)"),
        ("severity" = Option<String>, Query, description = "Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)"),
    ),
    responses(
        (status = 200, description = "List of vulnerabilities", body = Vec<VulnerabilityResponse>),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_scan_vulnerabilities(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
    Query(query): Query<ListVulnerabilitiesQuery>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let severity_filter = query
        .severity
        .as_ref()
        .map(|s| parse_severity_string(s))
        .transpose()
        .map_err(|e: String| {
            Problem::from(ServiceError::Internal(format!("Invalid severity: {}", e)))
        })?;

    let (vulnerabilities, total) = app_state
        .scan_service
        .get_vulnerabilities(scan_id, severity_filter, query.page, query.page_size)
        .await?;

    let responses: Vec<VulnerabilityResponse> =
        vulnerabilities.into_iter().map(Into::into).collect();

    Ok(Json(serde_json::json!({
        "data": responses,
        "total": total,
        "page": query.page.unwrap_or(1),
        "page_size": query.page_size.unwrap_or(20),
    })))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/projects/{project_id}/vulnerability-scans/latest",
    params(
        ("project_id" = i32, Path, description = "Project ID"),
        ("environment_id" = Option<i32>, Query, description = "Filter by environment ID"),
    ),
    responses(
        (status = 200, description = "Latest scan for project", body = ScanResponse),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "No scans found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_latest_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
    Query(query): Query<serde_json::Value>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let environment_id = query
        .get("environment_id")
        .and_then(|v| v.as_i64())
        .map(|v| v as i32);

    let scan = app_state
        .scan_service
        .get_latest_scan(project_id, environment_id)
        .await?;

    match scan {
        Some(scan) => Ok(Json(ScanResponse::from(scan))),
        None => Err(Problem::from(ServiceError::NotFound(format!(
            "No scans found for project {}",
            project_id
        )))),
    }
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/projects/{project_id}/vulnerability-scans/environments",
    params(
        ("project_id" = i32, Path, description = "Project ID"),
    ),
    responses(
        (status = 200, description = "Latest scans per environment for current deployments", body = Vec<ScanResponse>),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_latest_scans_per_environment(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let scans = app_state
        .scan_service
        .get_latest_scans_per_environment(project_id)
        .await?;

    let responses: Vec<ScanResponse> = scans.into_iter().map(Into::into).collect();

    Ok(Json(responses))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/deployments/{deployment_id}/vulnerability-scan",
    params(
        ("deployment_id" = i32, Path, description = "Deployment ID"),
    ),
    responses(
        (status = 200, description = "Scan for the specified deployment", body = ScanResponse),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "No scan found for deployment", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_scan_by_deployment(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(deployment_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let scan = app_state
        .scan_service
        .get_scan_by_deployment(deployment_id)
        .await?;

    match scan {
        Some(scan) => Ok(Json(ScanResponse::from(scan))),
        None => Err(Problem::from(ServiceError::NotFound(format!(
            "No scan found for deployment {}",
            deployment_id
        )))),
    }
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    delete,
    path = "/vulnerability-scans/{scan_id}",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
    ),
    responses(
        (status = 204, description = "Scan deleted"),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn delete_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansDelete);

    app_state.scan_service.delete_scan(scan_id).await?;

    Ok(StatusCode::NO_CONTENT)
}

fn parse_severity_string(s: &str) -> Result<Severity, String> {
    match s.to_uppercase().as_str() {
        "CRITICAL" => Ok(Severity::Critical),
        "HIGH" => Ok(Severity::High),
        "MEDIUM" => Ok(Severity::Medium),
        "LOW" => Ok(Severity::Low),
        "UNKNOWN" => Ok(Severity::Unknown),
        _ => Err(format!(
            "Invalid severity: {}. Must be one of: CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN",
            s
        )),
    }
}
