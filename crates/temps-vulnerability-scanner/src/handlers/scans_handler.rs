use crate::scanner::Severity;
use crate::service::ServiceError;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    routing::get,
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use temps_auth::permission_guard;
use temps_auth::RequireAuth;
use temps_core::problemdetails;
use temps_core::problemdetails::{Problem, ProblemDetails};
use utoipa::{OpenApi, ToSchema};

use super::VulnerabilityScannerAppState;

impl From<ServiceError> for Problem {
    fn from(error: ServiceError) -> Self {
        match error {
            ServiceError::Database(e) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Database Error")
                .with_detail(e.to_string()),

            ServiceError::Scanner(e) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Scanner Error")
                .with_detail(e.to_string()),

            ServiceError::NotFound(msg) => problemdetails::new(StatusCode::NOT_FOUND)
                .with_title("Resource Not Found")
                .with_detail(msg),

            ServiceError::InvalidStatus(msg) => problemdetails::new(StatusCode::BAD_REQUEST)
                .with_title("Invalid Status")
                .with_detail(msg),

            ServiceError::Internal(msg) => problemdetails::new(StatusCode::INTERNAL_SERVER_ERROR)
                .with_title("Internal Server Error")
                .with_detail(msg),
        }
    }
}

#[derive(OpenApi)]
#[openapi(
    paths(
        list_project_scans,
        get_scan,
        get_scan_vulnerabilities,
        get_latest_scan,
        delete_scan
    ),
    components(
        schemas(
            ScanResponse,
            VulnerabilityResponse,
            ListScansQuery,
            ListVulnerabilitiesQuery,
        )
    ),
    info(
        title = "Vulnerability Scanner API",
        description = "API endpoints for managing vulnerability scans. \
        Provides endpoints to view scan results, vulnerabilities, and scan history.",
        version = "1.0.0"
    ),
    tags(
        (name = "Vulnerability Scans", description = "Vulnerability scan management endpoints")
    )
)]
pub struct ScansApiDoc;

#[derive(Serialize, ToSchema)]
pub struct ScanResponse {
    pub id: i32,
    pub project_id: i32,
    pub environment_id: Option<i32>,
    pub branch: Option<String>,
    pub commit_hash: Option<String>,
    pub scanner_type: String,
    pub scanner_version: Option<String>,
    pub status: String,
    pub total_count: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub unknown_count: i32,
    pub error_message: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub started_at: String,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub completed_at: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub created_at: String,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub updated_at: String,
}

impl From<temps_entities::vulnerability_scans::Model> for ScanResponse {
    fn from(scan: temps_entities::vulnerability_scans::Model) -> Self {
        Self {
            id: scan.id,
            project_id: scan.project_id,
            environment_id: scan.environment_id,
            branch: scan.branch,
            commit_hash: scan.commit_hash,
            scanner_type: scan.scanner_type,
            scanner_version: scan.scanner_version,
            status: scan.status,
            total_count: scan.total_count,
            critical_count: scan.critical_count,
            high_count: scan.high_count,
            medium_count: scan.medium_count,
            low_count: scan.low_count,
            unknown_count: scan.unknown_count,
            error_message: scan.error_message,
            started_at: scan.started_at.to_rfc3339(),
            completed_at: scan.completed_at.map(|dt| dt.to_rfc3339()),
            created_at: scan.created_at.to_rfc3339(),
            updated_at: scan.updated_at.to_rfc3339(),
        }
    }
}

#[derive(Serialize, ToSchema)]
pub struct VulnerabilityResponse {
    pub id: i32,
    pub scan_id: i32,
    pub vulnerability_id: String,
    pub package_name: String,
    pub installed_version: String,
    pub fixed_version: Option<String>,
    pub severity: String,
    pub title: String,
    pub description: Option<String>,
    pub references: Option<serde_json::Value>,
    pub cvss_score: Option<f32>,
    pub primary_url: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub published_date: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub last_modified_date: Option<String>,
    #[schema(example = "2025-12-08T12:15:47.609192Z")]
    pub created_at: String,
}

impl From<temps_entities::vulnerabilities::Model> for VulnerabilityResponse {
    fn from(vuln: temps_entities::vulnerabilities::Model) -> Self {
        Self {
            id: vuln.id,
            scan_id: vuln.scan_id,
            vulnerability_id: vuln.vulnerability_id,
            package_name: vuln.package_name,
            installed_version: vuln.installed_version,
            fixed_version: vuln.fixed_version,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            references: vuln.references,
            cvss_score: vuln.cvss_score,
            primary_url: vuln.primary_url,
            published_date: vuln.published_date.map(|dt| dt.to_rfc3339()),
            last_modified_date: vuln.last_modified_date.map(|dt| dt.to_rfc3339()),
            created_at: vuln.created_at.to_rfc3339(),
        }
    }
}

#[derive(Deserialize, ToSchema)]
pub struct ListScansQuery {
    #[schema(example = 1)]
    pub page: Option<u64>,
    #[schema(example = 20)]
    pub page_size: Option<u64>,
}

#[derive(Deserialize, ToSchema)]
pub struct ListVulnerabilitiesQuery {
    #[schema(example = 1)]
    pub page: Option<u64>,
    #[schema(example = 20)]
    pub page_size: Option<u64>,
    #[schema(example = "CRITICAL")]
    pub severity: Option<String>,
}

pub fn configure_routes() -> Router<Arc<VulnerabilityScannerAppState>> {
    Router::new()
        .route(
            "/projects/{project_id}/vulnerability-scans",
            get(list_project_scans),
        )
        .route(
            "/projects/{project_id}/vulnerability-scans/latest",
            get(get_latest_scan),
        )
        .route(
            "/vulnerability-scans/{scan_id}",
            get(get_scan).delete(delete_scan),
        )
        .route(
            "/vulnerability-scans/{scan_id}/vulnerabilities",
            get(get_scan_vulnerabilities),
        )
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/projects/{project_id}/vulnerability-scans",
    params(
        ("project_id" = i32, Path, description = "Project ID"),
        ("page" = Option<u64>, Query, description = "Page number (default: 1)"),
        ("page_size" = Option<u64>, Query, description = "Page size (default: 20, max: 100)"),
    ),
    responses(
        (status = 200, description = "List of vulnerability scans", body = Vec<ScanResponse>),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn list_project_scans(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
    Query(query): Query<ListScansQuery>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let (scans, total) = app_state
        .scan_service
        .get_project_scans(project_id, query.page, query.page_size)
        .await?;

    let responses: Vec<ScanResponse> = scans.into_iter().map(Into::into).collect();

    Ok(Json(serde_json::json!({
        "data": responses,
        "total": total,
        "page": query.page.unwrap_or(1),
        "page_size": query.page_size.unwrap_or(20),
    })))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/vulnerability-scans/{scan_id}",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
    ),
    responses(
        (status = 200, description = "Scan details", body = ScanResponse),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let scan = app_state.scan_service.get_scan(scan_id).await?;

    Ok(Json(ScanResponse::from(scan)))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/vulnerability-scans/{scan_id}/vulnerabilities",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
        ("page" = Option<u64>, Query, description = "Page number (default: 1)"),
        ("page_size" = Option<u64>, Query, description = "Page size (default: 20, max: 100)"),
        ("severity" = Option<String>, Query, description = "Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)"),
    ),
    responses(
        (status = 200, description = "List of vulnerabilities", body = Vec<VulnerabilityResponse>),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_scan_vulnerabilities(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
    Query(query): Query<ListVulnerabilitiesQuery>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let severity_filter = query
        .severity
        .as_ref()
        .map(|s| parse_severity_string(s))
        .transpose()
        .map_err(|e: String| {
            Problem::from(ServiceError::Internal(format!("Invalid severity: {}", e)))
        })?;

    let (vulnerabilities, total) = app_state
        .scan_service
        .get_vulnerabilities(scan_id, severity_filter, query.page, query.page_size)
        .await?;

    let responses: Vec<VulnerabilityResponse> =
        vulnerabilities.into_iter().map(Into::into).collect();

    Ok(Json(serde_json::json!({
        "data": responses,
        "total": total,
        "page": query.page.unwrap_or(1),
        "page_size": query.page_size.unwrap_or(20),
    })))
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    get,
    path = "/projects/{project_id}/vulnerability-scans/latest",
    params(
        ("project_id" = i32, Path, description = "Project ID"),
        ("environment_id" = Option<i32>, Query, description = "Filter by environment ID"),
    ),
    responses(
        (status = 200, description = "Latest scan for project", body = ScanResponse),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "No scans found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn get_latest_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(project_id): Path<i32>,
    Query(query): Query<serde_json::Value>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansRead);

    let environment_id = query
        .get("environment_id")
        .and_then(|v| v.as_i64())
        .map(|v| v as i32);

    let scan = app_state
        .scan_service
        .get_latest_scan(project_id, environment_id)
        .await?;

    match scan {
        Some(scan) => Ok(Json(ScanResponse::from(scan))),
        None => Err(Problem::from(ServiceError::NotFound(format!(
            "No scans found for project {}",
            project_id
        )))),
    }
}

#[utoipa::path(
    tag = "Vulnerability Scans",
    delete,
    path = "/vulnerability-scans/{scan_id}",
    params(
        ("scan_id" = i32, Path, description = "Scan ID"),
    ),
    responses(
        (status = 204, description = "Scan deleted"),
        (status = 401, description = "Unauthorized", body = ProblemDetails),
        (status = 403, description = "Insufficient permissions", body = ProblemDetails),
        (status = 404, description = "Scan not found", body = ProblemDetails),
        (status = 500, description = "Internal server error", body = ProblemDetails)
    ),
    security(("bearer_auth" = []))
)]
async fn delete_scan(
    RequireAuth(auth): RequireAuth,
    State(app_state): State<Arc<VulnerabilityScannerAppState>>,
    Path(scan_id): Path<i32>,
) -> Result<impl IntoResponse, Problem> {
    permission_guard!(auth, VulnerabilityScansDelete);

    app_state.scan_service.delete_scan(scan_id).await?;

    Ok(StatusCode::NO_CONTENT)
}

fn parse_severity_string(s: &str) -> Result<Severity, String> {
    match s.to_uppercase().as_str() {
        "CRITICAL" => Ok(Severity::Critical),
        "HIGH" => Ok(Severity::High),
        "MEDIUM" => Ok(Severity::Medium),
        "LOW" => Ok(Severity::Low),
        "UNKNOWN" => Ok(Severity::Unknown),
        _ => Err(format!(
            "Invalid severity: {}. Must be one of: CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN",
            s
        )),
    }
}
