# Temps CAPTCHA WebAssembly

High-performance proof-of-work CAPTCHA solver compiled to WebAssembly for browser-based execution.

## Overview

This module provides a fast proof-of-work challenge solver that runs in the browser using WebAssembly. It's used to protect against bot attacks by requiring visitors to compute a proof-of-work before accessing the site.

**Performance: ~50x faster than pure JavaScript**

## Building

```bash
# Install wasm-pack if not already installed
cargo install wasm-pack

# Build the WASM module
cd crates/temps-captcha-wasm
wasm-pack build --target web --release

# Or using npm/bun
npm run build
bun run build
```

## Output

The build creates `pkg/` directory with:
- `temps_captcha_wasm_bg.wasm` - The compiled WebAssembly module (~100KB)
- `temps_captcha_wasm.js` - JavaScript bindings (auto-generated by wasm-bindgen)
- `temps_captcha_wasm.d.ts` - TypeScript type definitions

## Performance Characteristics

Compared to pure JavaScript implementation using `crypto.subtle.digest()`:

| Metric | WASM | JavaScript | Speedup |
|--------|------|------------|---------|
| Hash Computation | ~20-30ms per 10k hashes | ~1000-2000ms per 10k hashes | **50x faster** |
| 20-bit Challenge (typ.) | **500-1500ms** | **2-5 seconds** | **3-10x faster** |
| Hash Rate | **500k-1M hashes/sec** | **10k-50k hashes/sec** | **50x faster** |
| Solution Time | **0.5-1 seconds** | **2-5 seconds** | **5-10x improvement** |

### Why WASM is so much faster:

1. **Raw Binary Operations**: Works directly with byte arrays instead of hex string conversions
2. **Optimized SHA-256**: Uses the `sha2` crate with platform-specific optimizations
3. **No String Allocations**: Hash verification uses raw bytes, avoiding string overhead
4. **Inline Functions**: Compiler can inline hot functions (`compute_hash`, `has_leading_zero_bits`)
5. **Better CPU Utilization**: Native code can use SIMD and other CPU features

## API

### `solve_challenge(challenge: string, difficulty: u32, callback: Function) -> Result<string, JsError>`

Solves a proof-of-work challenge by finding a nonce that produces a hash with the required leading zero bits.

**Parameters:**
- `challenge`: Challenge string (typically hex-encoded random value, 32 chars)
- `difficulty`: Number of leading zero bits required (8-32)
- `callback`: Progress callback function `(nonce: number, hash: string) => void` called every 10,000 attempts

**Returns:** Promise resolving to nonce string, or error if exceeding safety limit

**Example:**
```javascript
const nonce = await solve_challenge(
  'abc123def456...',  // challenge
  20,                  // difficulty: 20 bits (~1-2M attempts)
  (nonce, hash) => console.log(`Progress: ${nonce} attempts, hash: ${hash}`)
);
console.log('Solution:', nonce);
```

### `verify_solution(challenge: string, nonce: string, difficulty: u32) -> boolean`

Verifies that a nonce produces a valid hash for the given challenge and difficulty.

**Parameters:**
- `challenge`: Original challenge string
- `nonce`: Nonce to verify (as string)
- `difficulty`: Required leading zero bits

**Returns:** `true` if valid, `false` otherwise

**Example:**
```javascript
const isValid = verify_solution('abc123...', '12345', 20);
console.log('Valid:', isValid);
```

## Integration with Temps Proxy

The WASM module is served from the proxy at `/__temps/captcha-wasm.js` and `/__temps/captcha-wasm_bg.wasm`.

The challenge HTML (`captcha/challenge.html`) automatically:
1. Loads the WASM module
2. Falls back to pure JavaScript if WASM fails
3. Shows progress updates to the user
4. Submits the solution for verification

## Difficulty Levels

Typical difficulty levels and expected computation times:

| Bits | Avg. Attempts | WASM Time | JS Time | Use Case |
|------|---------------|-----------|---------|----------|
| 15 | ~33k | 30-50ms | 200-500ms | Test/Debug |
| 18 | ~262k | 250-500ms | 1-2s | Light protection |
| 20 | ~1M | 500-1500ms | 2-5s | Standard (Default) |
| 22 | ~4M | 2-4s | 8-20s | Medium attack |
| 24 | ~16M | 8-15s | 30-60s | Heavy attack |

**Current Default:** 20 bits (typical solution time: 0.5-1.5 seconds with WASM)

## Testing

```bash
# Run unit tests
cargo test --lib -p temps-captcha-wasm

# Run wasm tests (requires wasm-pack and wasm-bindgen-test)
wasm-pack test --headless --firefox
```

## Troubleshooting

### WASM module fails to load

The challenge HTML includes automatic fallback to pure JavaScript:
- If WASM fails to load or initialize, the solver automatically falls back
- User experience degrades to 2-5 second solution time instead of 0.5-1.5s
- Check browser console for error messages

### Solution takes too long

- Check difficulty level (20 bits is standard, 24+ bits may timeout)
- Verify browser is not throttled (DevTools Throttling)
- Check CPU usage - WASM may be competing with other tabs/processes

### "Difficulty cannot exceed 32 bits" error

The WASM module limits difficulty to 32 bits (256 total bits) to prevent infinite loops. This is a safety measure.

## Build Artifacts

The pre-built WASM files are checked into git at `crates/temps-captcha-wasm/pkg/`:
- `temps_captcha_wasm_bg.wasm` - Binary WASM module
- `temps_captcha_wasm.js` - Auto-generated JavaScript bindings
- `package.json` - NPM metadata

To rebuild after code changes:
```bash
cd crates/temps-captcha-wasm
wasm-pack build --target web --release
```
